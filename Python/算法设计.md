# 排序算法

## 冒泡排序

```python
# 固定比较方法, 简单, 修改原数据
def bubble_sort(arr):
	n = len(arr)
	for i in range(n):
		for j in range(n-i-1):
			if arr[j] > arr[j+1]:
				arr[j], arr[j+1] = arr[j+1], arr[j]
	return arr

# 灵活, 自定义比较方法, 不改变原数据
def bubble_sort(items, comp=lambda x, y: x > y):
    """冒泡排序"""
    items = items[:]
    for i in range(len(items) - 1):
        swapped = False
        for j in range(len(items) - 1 - i):
            if comp(items[j], items[j + 1]):
                items[j], items[j + 1] = items[j + 1], items[j]
                swapped = True
        if not swapped:
            break
    return items
```

## 搅拌排序

冒泡排序升级版

```python
def bubble_sort(items, comp=lambda x, y: x > y):
    """搅拌排序(冒泡排序升级版)"""
    items = items[:]
    for i in range(len(items) - 1):
        swapped = False
        for j in range(len(items) - 1 - i):
            if comp(items[j], items[j + 1]):
                items[j], items[j + 1] = items[j + 1], items[j]
                swapped = True
        if swapped:
            swapped = False
            for j in range(len(items) - 2 - i, i, -1):
                if comp(items[j - 1], items[j]):
                    items[j], items[j - 1] = items[j - 1], items[j]
                    swapped = True
        if not swapped:
            break
    return items
```

## 选择排序

```python
# 固定比较方法, 简单, 修改原数据
def selection_sort(lst):
	for i in range(len(lst) - 1):
		min_index = i
		for j in range(i + 1, len(lst)):
			if lst[j] < lst[min_index]:
				min_index = j
		lst[i], lst[min_index] = lst[min_index], lst[i]
	return lst

# 灵活, 自定义比较方法, 不改变原数据
def selection_sort(lst, comp=lambda x, y: x < y):
    """
    通用选择排序算法
  
    :param lst: 待排序列表
    :param comp: 比较函数, 默认为升序排序
    :return: 排序后的新列表
    """
    lst = lst[:]  # 复制列表, 避免修改原始数据
    for i in range(len(lst) - 1):
        min_index = i
        for j in range(i + 1, len(lst)):
            if comp(lst[j], lst[min_index]):
                min_index = j
        lst[i], lst[min_index] = lst[min_index], lst[i]
    return lst

```

## 快速排序

```python
def quick_sort(array, start, end):
	if start >= end:
		return
	mid_data, left, right = array[start], start, end
	while left < right:
		while array[right] >= mid_data and left < right:
			righy -= 1
		array[left] = arrat[right]
		while array[left] < mid_date and left < right:
			left += 1
		array[right] = mid_data
	array[left] = mid_data
	quick_sort(array, start, left-1)
	quick_sort(array, left+1, end)

# 灵活版本
def quick_sort(items, comp=lambda x, y: x <= y):
    items = list(items)[:]
    _quick_sort(items, 0, len(items) - 1, comp)
    return items

def _quick_sort(items, start, end, comp):
    if start < end:
        pos = _partition(items, start, end, comp)
        _quick_sort(items, start, pos - 1, comp)
        _quick_sort(items, pos + 1, end, comp)

def _partition(items, start, end, comp):
    pivot = items[end]
    i = start - 1
    for j in range(start, end):
        if comp(items[j], pivot):
            i += 1
            items[i], items[j] = items[j], items[i]
            items[i + 1], items[end] = items[end], items[i + 1]
            return i + 1
```

## 归并排序

```python
def merge(items1, items2, comp=lambda x, y: x < y):
"""合并(将两个有序的列表合并成一个有序的列表)"""
	items = []
	index1, index2 = 0, 0
	while index1 < len(items1) and index2 < len(items2):
    	if comp(items1[index1], items2[index2]):
        	items.append(items1[index1])
        	index1 += 1
    	else:
        	items.append(items2[index2])
        	index2 += 1
        	items += items1[index1:]
        	items += items2[index2:]
    return items


def merge_sort(items, comp=lambda x, y: x < y):
    return _merge_sort(list(items), comp)


def _merge_sort(items, comp):
    """归并排序"""
    if len(items) < 2:
        return items
    mid = len(items) // 2
    left = _merge_sort(items[:mid], comp)
    right = _merge_sort(items[mid:], comp)
    return merge(left, right, comp)
```

## 猴子排序

# 查找算法

## 顺序查找

```python
def seq_search(items, key):
    """顺序查找"""
    for index, item in enumerate(items):
        if item == key:
            return index
    return -1
```

## 折半查找

```python
def bin_search(items, key):
    """折半查找"""
    start, end = 0, len(items) - 1
    while start <= end:
        mid = (start + end) // 2
        if key > items[mid]:
            start = mid + 1
        elif key < items[mid]:
            end = mid - 1
        else:
            return mid
    return -1
```

# 算法设计

## 穷举法

暴力破解法, 对所有的可能性进行验证, 直到找到正确答案

- 百钱百鸡问题:

    ```python
    # 公鸡5元一只 母鸡3元一只 小鸡1元三只
    # 用100元买100只鸡 问公鸡/母鸡/小鸡各多少只
    for x in range(20):
        for y in range(33):
            z = 100 - x - y
            if 5 * x + 3 * y + z // 3 == 100 and z % 3 == 0:
                print(x, y, z)
    ```

- 五人分鱼问题: 

    ```python
    # A、B、C、D、E五人在某天夜里合伙捕鱼 最后疲惫不堪各自睡觉
    # 第二天A第一个醒来 他将鱼分为5份 扔掉多余的1条 拿走自己的一份
    # B第二个醒来 也将鱼分为5份 扔掉多余的1条 拿走自己的一份
    # 然后C、D、E依次醒来也按同样的方式分鱼 问他们至少捕了多少条鱼
    fish = 6
    while True:
        total = fish
        enough = True
        for _ in range(5):
            if (total - 1) % 5 == 0:
                total = (total - 1) // 5 * 4
            else:
                enough = False
                break
        if enough:
            print(fish)
            break
        fish += 5
    ```

## 贪婪法

在对问题求解时, 总是做出在当前看来最好的选择, 不追求最优解, 快速找到满意解

贪婪小偷问题: 

| 名称   | 价格(美元) | 重量(kg) |
| ------ | ---------- | -------- |
| 电脑   | 200        | 20       |
| 收音机 | 20         | 4        |
| 钟     | 175        | 10       |
| 花瓶   | 50         | 2        |
| 书     | 10         | 1        |
| 油画   | 90         | 9        |

```python
class Thing(object):
    """物品"""

    def __init__(self, name, price, weight):
        self.name = name
        self.price = price
        self.weight = weight

    @property
    def value(self):
        """价格重量比"""
        return self.price / self.weight
    
    def input_thing():
    """输入物品信息"""
    	name_str, price_str, weight_str = input().split()
    	return name_str, int(price_str), int(weight_str)
    
def main():
    """主函数"""
    max_weight, num_of_things = map(int, input().split())
    all_things = []
    for _ in range(num_of_things):
        all_things.append(Thing(*input_thing()))
    all_things.sort(key=lambda x: x.value, reverse=True)
    total_weight = 0
    total_price = 0
    for thing in all_things:
        if total_weight + thing.weight <= max_weight:
            print(f'小偷拿走了{thing.name}')
            total_weight += thing.weight
            total_price += thing.price
    print(f'总价值: {total_price}美元')

if __name__ == '__main__':
    main()
```

## 分治法

把一个复杂的问题分成两个或更多的相同或相似的子问题, 再把子问题分成更小的子问题, 直到可以直接求解的程度, 最后将子问题的解进行合并得到原问题的解

eg：快速排序

## 回溯法

试探法, 按选优条件向前搜索, 当搜索到某一步发现原先选择并不优或达不到目标时, 就退回一步重新选择

骑士巡逻问题: 

```python
import sys
import time

SIZE = 5
total = 0

def print_board(board):
    for row in board:
        for col in row:
            print(str(col).center(4), end='')
        print()
        
def patrol(board, row, col, step=1):
    if row >= 0 and row < SIZE and \
        col >= 0 and col < SIZE and \
        board[row][col] == 0:
        board[row][col] = step
        if step == SIZE * SIZE:
            global total
            total += 1
            print(f'第{total}种走法: ')
            print_board(board)
        patrol(board, row - 2, col - 1, step + 1)
        patrol(board, row - 1, col - 2, step + 1)
        patrol(board, row + 1, col - 2, step + 1)
        patrol(board, row + 2, col - 1, step + 1)
        patrol(board, row + 2, col + 1, step + 1)
        patrol(board, row + 1, col + 2, step + 1)
        patrol(board, row - 1, col + 2, step + 1)
        patrol(board, row - 2, col + 1, step + 1)
        board[row][col] = 0
        
def main():
    board = [[0] * SIZE for _ in range(SIZE)]
    patrol(board, SIZE - 1, SIZE - 1)

if __name__ == '__main__':
    main()
```

## 动态规划

将待求解问题分解成若干个子问题, 先求解并保存这些子问题的解, 避免产生大量的重复运算

- 子列表元素之和的最大值: 子列表指的是列表中索引连续的元素构成的列表, 元素是int类型, 可能包含正整数、0、负整数

    ```python
    # 二重循环性能差, 动态规划性能好
    def main():
        items = list(map(int, input().split()))
        overall = partial = items[0]
        for i in range(1, len(items)):
            partial = max(items[i], partial + items[i]) 	# 当前最大值
            overall = max(partial, overall)		# 全局最大值
        print(overall)
        
    if __name__ == '__main__':
        main()
    ```

# 经典题目

## 1. 反转字符串

```python
def reverse_string(s):
    return s[::-1]
```

## 2. 检测链表中的环

判断一个单链表是否有环, 要求空间复杂度O(1)

快慢指针法: 

```python
class ListNode:
    def __init__(self, val=0):
        self.val = val
        self.next = None

def has_cycle(head):
    slow = fast = head
    while fast and fast.next:
        slow = slow.next
        fast = fast.next.next
        if slow == fast:
            return True
    return False
```

## 3. 两数之和

给定一个整数数组和一个目标值, 找出和为目标值的两个数的索引

```python
def two_sum(nums, target):
    seen = {}
    for i, num in enumerate(nums):
        complement = target - num
        if complement in seen:
            return [seen[complement], i]
        seen[num] = i
    return []
```


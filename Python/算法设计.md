# 排序算法

## 冒泡排序

```python
# 固定比较方法, 简单, 修改原数据
def bubble_sort(arr):
	n = len(arr)
	for i in range(n):
		for j in range(n-i-1):
			if arr[j] > arr[j+1]:
				arr[j], arr[j+1] = arr[j+1], arr[j]
	return arr

# 灵活, 自定义比较方法, 不改变原数据
def bubble_sort(items, comp=lambda x, y: x > y):
    """冒泡排序"""
    items = items[:]
    for i in range(len(items) - 1):
        swapped = False
        for j in range(len(items) - 1 - i):
            if comp(items[j], items[j + 1]):
                items[j], items[j + 1] = items[j + 1], items[j]
                swapped = True
        if not swapped:
            break
    return items
```

## 搅拌排序

冒泡排序升级版

```python
def bubble_sort(items, comp=lambda x, y: x > y):
    """搅拌排序(冒泡排序升级版)"""
    items = items[:]
    for i in range(len(items) - 1):
        swapped = False
        for j in range(len(items) - 1 - i):
            if comp(items[j], items[j + 1]):
                items[j], items[j + 1] = items[j + 1], items[j]
                swapped = True
        if swapped:
            swapped = False
            for j in range(len(items) - 2 - i, i, -1):
                if comp(items[j - 1], items[j]):
                    items[j], items[j - 1] = items[j - 1], items[j]
                    swapped = True
        if not swapped:
            break
    return items
```

## 选择排序

```python
# 固定比较方法, 简单, 修改原数据
def selection_sort(lst):
	for i in range(len(lst) - 1):
		min_index = i
		for j in range(i + 1, len(lst)):
			if lst[j] < lst[min_index]:
				min_index = j
		lst[i], lst[min_index] = lst[min_index], lst[i]
	return lst

# 灵活, 自定义比较方法, 不改变原数据
def selection_sort(lst, comp=lambda x, y: x < y):
    """
    通用选择排序算法
  
    :param lst: 待排序列表
    :param comp: 比较函数, 默认为升序排序
    :return: 排序后的新列表
    """
    lst = lst[:]  # 复制列表, 避免修改原始数据
    for i in range(len(lst) - 1):
        min_index = i
        for j in range(i + 1, len(lst)):
            if comp(lst[j], lst[min_index]):
                min_index = j
        lst[i], lst[min_index] = lst[min_index], lst[i]
    return lst

```

## 快速排序

```python
def quick_sort(array, start, end):
	if start >= end:
		return
	mid_data, left, right = array[start], start, end
	while left < right:
		while array[right] >= mid_data and left < right:
			righy -= 1
		array[left] = arrat[right]
		while array[left] < mid_date and left < right:
			left += 1
		array[right] = mid_data
	array[left] = mid_data
	quick_sort(array, start, left-1)
	quick_sort(array, left+1, end)

# 灵活版本
def quick_sort(items, comp=lambda x, y: x <= y):
    items = list(items)[:]
    _quick_sort(items, 0, len(items) - 1, comp)
    return items

def _quick_sort(items, start, end, comp):
    if start < end:
        pos = _partition(items, start, end, comp)
        _quick_sort(items, start, pos - 1, comp)
        _quick_sort(items, pos + 1, end, comp)

def _partition(items, start, end, comp):
    pivot = items[end]
    i = start - 1
    for j in range(start, end):
        if comp(items[j], pivot):
            i += 1
            items[i], items[j] = items[j], items[i]
            items[i + 1], items[end] = items[end], items[i + 1]
            return i + 1
```

## 归并排序

```python
def merge(items1, items2, comp=lambda x, y: x < y):
"""合并(将两个有序的列表合并成一个有序的列表)"""
	items = []
	index1, index2 = 0, 0
	while index1 < len(items1) and index2 < len(items2):
    	if comp(items1[index1], items2[index2]):
        	items.append(items1[index1])
        	index1 += 1
    	else:
        	items.append(items2[index2])
        	index2 += 1
        	items += items1[index1:]
        	items += items2[index2:]
    return items


def merge_sort(items, comp=lambda x, y: x < y):
    return _merge_sort(list(items), comp)


def _merge_sort(items, comp):
    """归并排序"""
    if len(items) < 2:
        return items
    mid = len(items) // 2
    left = _merge_sort(items[:mid], comp)
    right = _merge_sort(items[mid:], comp)
    return merge(left, right, comp)
```

## 猴子排序

# 查找算法

## 顺序查找

```python
def seq_search(items, key):
    """顺序查找"""
    for index, item in enumerate(items):
        if item == key:
            return index
    return -1
```

## 折半查找

```python
def bin_search(items, key):
    """折半查找"""
    start, end = 0, len(items) - 1
    while start <= end:
        mid = (start + end) // 2
        if key > items[mid]:
            start = mid + 1
        elif key < items[mid]:
            end = mid - 1
        else:
            return mid
    return -1
```

# 算法设计

## 穷举法

暴力破解法, 对所有的可能性进行验证, 直到找到正确答案

- 百钱百鸡问题:

    ```python
    # 公鸡5元一只 母鸡3元一只 小鸡1元三只
    # 用100元买100只鸡 问公鸡/母鸡/小鸡各多少只
    for x in range(20):
        for y in range(33):
            z = 100 - x - y
            if 5 * x + 3 * y + z // 3 == 100 and z % 3 == 0:
                print(x, y, z)
    ```

- 五人分鱼问题: 

    ```python
    # A、B、C、D、E五人在某天夜里合伙捕鱼 最后疲惫不堪各自睡觉
    # 第二天A第一个醒来 他将鱼分为5份 扔掉多余的1条 拿走自己的一份
    # B第二个醒来 也将鱼分为5份 扔掉多余的1条 拿走自己的一份
    # 然后C、D、E依次醒来也按同样的方式分鱼 问他们至少捕了多少条鱼
    fish = 6
    while True:
        total = fish
        enough = True
        for _ in range(5):
            if (total - 1) % 5 == 0:
                total = (total - 1) // 5 * 4
            else:
                enough = False
                break
        if enough:
            print(fish)
            break
        fish += 5
    ```

## 贪婪法

在对问题求解时, 总是做出在当前看来最好的选择, 不追求最优解, 快速找到满意解

贪婪小偷问题: 

| 名称   | 价格(美元) | 重量(kg) |
| ------ | ---------- | -------- |
| 电脑   | 200        | 20       |
| 收音机 | 20         | 4        |
| 钟     | 175        | 10       |
| 花瓶   | 50         | 2        |
| 书     | 10         | 1        |
| 油画   | 90         | 9        |

```python
class Thing(object):
    """物品"""

    def __init__(self, name, price, weight):
        self.name = name
        self.price = price
        self.weight = weight

    @property
    def value(self):
        """价格重量比"""
        return self.price / self.weight
    
    def input_thing():
    """输入物品信息"""
    	name_str, price_str, weight_str = input().split()
    	return name_str, int(price_str), int(weight_str)
    
def main():
    """主函数"""
    max_weight, num_of_things = map(int, input().split())
    all_things = []
    for _ in range(num_of_things):
        all_things.append(Thing(*input_thing()))
    all_things.sort(key=lambda x: x.value, reverse=True)
    total_weight = 0
    total_price = 0
    for thing in all_things:
        if total_weight + thing.weight <= max_weight:
            print(f'小偷拿走了{thing.name}')
            total_weight += thing.weight
            total_price += thing.price
    print(f'总价值: {total_price}美元')

if __name__ == '__main__':
    main()
```

## 分治法

把一个复杂的问题分成两个或更多的相同或相似的子问题, 再把子问题分成更小的子问题, 直到可以直接求解的程度, 最后将子问题的解进行合并得到原问题的解

eg：快速排序

## 回溯法

试探法, 按选优条件向前搜索, 当搜索到某一步发现原先选择并不优或达不到目标时, 就退回一步重新选择

骑士巡逻问题: 

```python
import sys
import time

SIZE = 5
total = 0

def print_board(board):
    for row in board:
        for col in row:
            print(str(col).center(4), end='')
        print()
        
def patrol(board, row, col, step=1):
    if row >= 0 and row < SIZE and \
        col >= 0 and col < SIZE and \
        board[row][col] == 0:
        board[row][col] = step
        if step == SIZE * SIZE:
            global total
            total += 1
            print(f'第{total}种走法: ')
            print_board(board)
        patrol(board, row - 2, col - 1, step + 1)
        patrol(board, row - 1, col - 2, step + 1)
        patrol(board, row + 1, col - 2, step + 1)
        patrol(board, row + 2, col - 1, step + 1)
        patrol(board, row + 2, col + 1, step + 1)
        patrol(board, row + 1, col + 2, step + 1)
        patrol(board, row - 1, col + 2, step + 1)
        patrol(board, row - 2, col + 1, step + 1)
        board[row][col] = 0
        
def main():
    board = [[0] * SIZE for _ in range(SIZE)]
    patrol(board, SIZE - 1, SIZE - 1)

if __name__ == '__main__':
    main()
```

## 动态规划

将待求解问题分解成若干个子问题, 先求解并保存这些子问题的解, 避免产生大量的重复运算

- 子列表元素之和的最大值: 子列表指的是列表中索引连续的元素构成的列表, 元素是int类型, 可能包含正整数、0、负整数

    ```python
    # 二重循环性能差, 动态规划性能好
    def main():
        items = list(map(int, input().split()))
        overall = partial = items[0]
        for i in range(1, len(items)):
            partial = max(items[i], partial + items[i]) 	# 当前最大值
            overall = max(partial, overall)		# 全局最大值
        print(overall)
        
    if __name__ == '__main__':
        main()
    ```

# 经典题目

## 1. 反转字符串

```python
def reverse_string(s):
    return s[::-1]
```

## 2. 检测链表中的环

判断一个单链表是否有环, 要求空间复杂度O(1)

快慢指针法: 

```python
class ListNode:
    def __init__(self, val=0):
        self.val = val
        self.next = None

def has_cycle(head):
    slow = fast = head
    while fast and fast.next:
        slow = slow.next
        fast = fast.next.next
        if slow == fast:
            return True
    return False
```

## 3. 两数之和

给定一个整数数组和一个目标值, 找出和为目标值的两个数的索引

```python
def two_sum(nums, target):
    seen = {}
    for i, num in enumerate(nums):
        complement = target - num
        if complement in seen:
            return [seen[complement], i]
        seen[num] = i
    return []
```

## 4. 用堆实现动态跟踪中位数

要追踪一个动态增长序列的中位数, 我们可以使用一个 **大根堆** 和一个 **小根堆** 来高效地处理。

### 思路: 

1. **大根堆**: 存储比中位数小的部分元素。我们可以通过使用 Python 中的 `heapq`​ 模块的负数来模拟大根堆, 因为 `heapq`​ 实际上是一个小根堆。
2. **小根堆**: 存储比中位数大的部分元素。

这两种堆的大小需要保持以下性质: 

- **大根堆** 中的元素数量要么等于 **小根堆**, 要么比 **小根堆** 多 1 个。
- 如果大根堆的大小比小根堆大, 我们从大根堆中取出最大元素作为中位数；否则从小根堆中取出最小元素作为中位数。

### 具体实现步骤: 

1. 如果插入的数比大根堆的最大元素还小, 将其加入大根堆；否则加入小根堆。
2. 如果大根堆的大小比小根堆大 2, 则将大根堆的最大元素移到小根堆中, 以保持大小平衡。
3. 如果小根堆的大小比大根堆大 2, 则将小根堆的最小元素移到大根堆中, 以保持大小平衡。
4. 每次查询中位数时, 直接返回两个堆的顶端元素, 根据堆的大小决定中位数。

### Python 代码实现: 

```python
import heapq

class MedianFinder:
    def __init__(self):
        # 大根堆(模拟), 存储较小的一半数
        self.max_heap = []  # 存储负数, 模拟大根堆
        # 小根堆, 存储较大的一半数
        self.min_heap = []
    
    def addNum(self, num: int):
        # 首先将数插入到大根堆或者小根堆
        if len(self.max_heap) == 0 or num <= -self.max_heap[0]:
            heapq.heappush(self.max_heap, -num)  # 插入负数来模拟大根堆
        else:
            heapq.heappush(self.min_heap, num)
        
        # 调整堆的大小, 保持平衡
        if len(self.max_heap) > len(self.min_heap) + 1:
            # 如果大根堆比小根堆多两个元素, 将最大元素移到小根堆
            heapq.heappush(self.min_heap, -heapq.heappop(self.max_heap))
        elif len(self.min_heap) > len(self.max_heap):
            # 如果小根堆比大根堆多一个元素, 将最小元素移到大根堆
            heapq.heappush(self.max_heap, -heapq.heappop(self.min_heap))
    
    def findMedian(self) -> float:
        if len(self.max_heap) > len(self.min_heap):
            # 如果大根堆多一个元素, 返回大根堆的最大元素
            return -self.max_heap[0]
        else:
            # 如果两个堆大小相等, 返回两个堆顶端元素的平均值
            return (-self.max_heap[0] + self.min_heap[0]) / 2

# 示例使用
mf = MedianFinder()
mf.addNum(1)
mf.addNum(2)
print(mf.findMedian())  # 输出 1.5
mf.addNum(3)
print(mf.findMedian())  # 输出 2.0
```

### 代码解释: 

1. **数据结构**: 

    - `max_heap`​ 使用负数来模拟大根堆。
    - `min_heap`​ 是普通的小根堆, 用于存储较大的一半元素。
2. **​`addNum`​**​ **方法**: 

    - 如果新元素比大根堆的最大元素还小, 插入到大根堆；否则, 插入到小根堆。
    - 之后进行堆大小调整: 大根堆如果多了 2 个元素, 移一个元素到小根堆；小根堆如果多了 1 个元素, 移一个元素到大根堆。
3. **​`findMedian`​**​ **方法**: 

    - 如果大根堆的大小比小根堆多, 返回大根堆的最大元素作为中位数。
    - 如果两个堆的大小相等, 则中位数是两个堆的堆顶元素的平均值。

### 时间复杂度: 

- **​`addNum`​**​ **方法**: 每次插入一个元素时, 堆的操作是对数时间复杂度, 因此时间复杂度是 **O(log n)** , 其中 `n`​ 是当前堆的元素个数。
- **​`findMedian`​**​ **方法**: 返回堆顶元素的操作是常数时间 **O(1)** 。

### 空间复杂度: 

- 使用了两个堆, 因此空间复杂度是 **O(n)** , 其中 `n`​ 是当前堆中的元素个数。

### 示例输出: 

```python
mf.addNum(1)
mf.addNum(2)
print(mf.findMedian())  # 输出 1.5
mf.addNum(3)
print(mf.findMedian())  # 输出 2.0
```

### 总结: 

通过使用一个大根堆和一个小根堆, 我们可以在插入每个新元素时保持动态序列的中位数。在最坏情况下, 插入操作的时间复杂度为 **O(log n)** , 而查询中位数的时间复杂度是 **O(1)** 。这种方法非常适合处理动态增长的序列。

## NP问题

Non-deterministic Polynomial Time，解的验证可以在多项式时间内完成的问题

**NP-Complete**：NP完全问题，算法设计和优化领域核心问题，满足两个条件的问题：

- **NP 问题**：问题能够在多项式时间内验证一个给定解的正确性
- **NP 完全性**：问题是 **NP** 类问题中的“最难”的问题，也就是说，任何其他 **NP** 问题都可以通过 **多项式时间** 的计算方法归约到该问题。如果某个 NP 完全问题能在多项式时间内解决，那么所有的 NP 问题都可以在多项式时间内解决

典型NP完全问题：**旅行商问题**（TSP）、**背包问题**、**图着色问题**、**哈密顿路径问题**、**3-SAT 问题**、**子集和问题**

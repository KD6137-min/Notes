# Python内存管理

## 内存结构

### 程序使用内存的划分(逻辑, 按地址从高到低):

- 栈`Stack`​: 存储局部、临时变量, 及函数调用时保存现场和恢复现场需要用到的数据(栈帧), 代码块开始执行时自动分配, 代码块执行结束时自动释放, 通常由编译器自动管理
- 静态区`Static Pool`​: 存储全局变量、静态变量, 程序结束释放
- 只读数据段`Read-Only Data Segment`​: 常量
- 代码段`Code Segment`​: 存储程序的机器码、Python字节码文件、模块等
- 方法区`Method Area`​: 存储类定义、方法定义、模块内容、元数据等
- 堆`Heap`​: 动态分配, 存储引用类型的对象, 垃圾回收机制自动清理内存

### Python和C++堆栈使用的区别:

- C++:

  - 局部变量直接在栈中分配, 自动释放
  - 使用`new`​的在堆中分配, 需要手动释放
- Python:

  - 栈中变量为对象的引用: 引用是高级抽象, 本质是通过变量名指向堆中的对象, 表示一个变量与对象的关联, 不直接表示内存地址, 而是指向某个对象的标识符, 可理解为对指针的封装, 使得我们通过变量名访问对象, 而不需要直接操作内存地址
  - 堆中存储所有对象, 无论对象是可变类型还是不可变类型
  - 通过引用计数和垃圾回收机制自动管理内存

## 垃圾回收机制GC

Garbage Collection, 在`引用计数机制`​基础上, 引入`标记—清除`​和`分代收集`​技术解决循环引用问题

```c
typedef struct _object {
    /* 引用计数 */
    int ob_refcnt;
    /* 对象指针 */
    struct _typeobject *ob_type;
} PyObject;

/* 增加引用计数的宏定义 */
#define Py_INCREF(op)   ((op)->ob_refcnt++)
/* 减少引用计数的宏定义 */
#define Py_DECREF(op) \ //减少计数
    if (--(op)->ob_refcnt != 0) \
        ; \
    else \
        __Py_Dealloc((PyObject *)(op))
```

### 导致引用+1的情况

- 对象被创建, 如`a = 23`​
- 对象被引用, 如`b = a`​
- 对象被作为参数, 传入到一个函数中, 如`f(a)`​
- 对象作为一个元素, 存储在容器中, 如`list1 = [a, a]`​

### 导致引用计数-1的情况

- 对象的别名被显式销毁, 如`del a`​
- 对象的别名被赋予新的对象, 如`a = 24`​
- 一个对象离开它的作用域, 如f函数执行完毕时, f函数中的局部变量
- 对象所在的容器被销毁, 或从容器中删除对象

### 解决循环引用

循环引用会导致内存泄漏

- **弱引用**: 一种引用对象的方式, 不阻止对象被垃圾回收(GC)机制回收, 允许引用一个对象却不增加该对象的引用计数, 从而不会影响垃圾回收器对该对象的回收, 常用于缓存和引用计数管理

  - ​`weakref`​模块, 创建弱引用: `weak_obj = weakref.ref(obj)`​
- **标记—清除**和**分代收集**技术: 在创建一个对象的时候, 对象被放在第一代中, 若在第一代的垃圾检查中对象存活了下来, 该对象就会被放到第二代中, 同理在第二代的垃圾检查中对象存活下来, 该对象就会被放到第三代中

### 导致垃圾回收的情况

- 调用`gc.collect()`​
- ​`gc`​模块的计数器达到阀值
- 程序退出

## 对象池

数值类型和字符串类型不可变, 每次修改实际为创建新对象

- 小整数对象池: 避免为整数频繁申请和销毁内存空间, [-5, 257), 不包括257, 范围内整数对象提前建立好, 不会被垃圾回收, 该范围内的整数均使用同一对象

- 大整数对象池: 每创建一个大整数时, 都会新建一个对象, 该对象引用计数为0时**不销毁**, 后面再建立的对象会**复用**之前已经不再使用的对象的内存空间
- 字符串对象缓冲池: 缓存单字节的字符对应的字符串对象(PyStringObject)

  - ​`intern`​机制: 用于将内容相同的字符串变量转换成指向同一个字符串对象, 维护一个名为`interned`​的集合, 存储(key, value)映射关系, 记录被intern机制处理过的 PyStringObject对象, 注意: intern机制是在字符串被创建后才起作用, Python始终会为字符串创建PyStringObject对象

    ```python
    >>> a = intern('a string') # 手动调用 intern 方法
    >>> b = intern('a string')
    >>> a is b
    True
    ```

## `__slots__`​优化

限制类的实例只允许特定的属性, 减少每个对象的内存开销(不再需要存储`__dict__`​)

每个实例对象都会有一个`__dict__`​属性, 用于存储实例的所有属性

‍

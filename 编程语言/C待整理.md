# 待整理

C语言提供了多种输入函数，涵盖格式化输入、字符输入、行输入、二进制输入等场景。以下是**C标准库及常用扩展**中的输入方法及其详细说明：

---

### 📜 核心输入函数分类与详解

#### 一、格式化输入函数

|函数名|头文件|功能特点|示例代码|注意事项|
| --------| --------| ---------------------------------------| ----------| --------------------------|
|​`scanf`​|​`<stdio.h>`​|按格式从标准输入读取数据|​`int a; scanf("%d", &a);`​|不安全（缓冲区溢出风险）|
|​`sscanf`​|​`<stdio.h>`​|从字符串中按格式提取数据|​`char s[100] = "123 45.6";`​<br />`sscanf(s, "%d%f", &a, &b);`​|返回成功匹配的字段数|
|​`scanf_s`​|​`<stdio.h>`​|安全版本的`scanf`​（C11标准，需编译器支持）|​`scanf_s("%d", &a, sizeof(int));`​|需指定缓冲区大小防止溢出|
|​`fscanf`​|​`<stdio.h>`​|从指定文件流按格式读取数据|​`FILE *fp; fscanf(fp, "%d", &a);`​|文件流必须已正确打开|

---

#### 二、字符级输入函数

|函数名|头文件|功能特点|示例代码|注意事项|
| --------| --------| ------------------------------------------| ----------| -------------------------------|
|​`getchar`​|​`<stdio.h>`​|读取单个字符（包括换行符`\n`​）|​`char c = getchar();`​|返回值是`int`​类型（EOF用-1表示）|
|​`fgetc`​|​`<stdio.h>`​|从指定文件流读取单个字符|​`char c = fgetc(fp);`​|文件流必须已正确打开|
|​`getc_unlocked`​|​`<stdio.h>`​|非锁定的快速版本（线程安全环境谨慎使用）|||
|​`getchar_unlocked`​|​`<stdio.h>`​|非锁定的`getchar`​版本|||

---

#### 三、行级输入函数

|函数名|头文件|功能特点|示例代码|注意事项|
| --------| --------| ----------------------------------------------| ----------| ------------------------------|
|​`gets`​|​`<stdio.h>`​|读取整行直到换行符或EOF（**危险函数！已弃用**）|​`char s[100]; gets(s);`​|缓冲区溢出风险，始终用`fgets`​替代|
|​`fgets`​|​`<stdio.h>`​|安全读取一行到缓冲区（包含换行符`\n`​）|​`fgets(s, 100, stdin);`​|需检查是否包含换行符|
|​`fgets_s`​|​`<stdio.h>`​|安全增强版`fgets`​（C11标准，需编译器支持）|​`fgets_s(s, 100, stdin);`​|需指定缓冲区大小|
|​`getline`​|​`<stdio.h>`​|动态分配缓冲区读取整行（POSIX扩展，非标准C）|​`char *line = getline(stdin, NULL, 0);`​|需释放动态内存|

---

#### 四、二进制输入函数

|函数名|头文件|功能特点|示例代码|注意事项|
| --------| --------| --------------------------------| ----------| ----------------------|
|​`fread`​|​`<stdio.h>`​|从文件流读取二进制数据到缓冲区|​`fread(buffer, size, count, fp);`​|返回实际读取的字节数|
|​`fread_unlocked`​|​`<stdio.h>`​|非锁定的二进制读取版本|||

---

#### 五、高级输入技巧

1. **自定义输入函数**  
    通过`ioctl`​系统调用直接操作终端设备（Linux/Unix专属）：

    ```c
    #include <unistd.h>
    int bytes_read;
    char buffer[1024];
    bytes_read = ioctl(STDIN_FILENO, FIONREAD, buffer); // 获取输入缓冲区字节数
    ```
2. **内存映射输入**  
    使用`mmap`​将文件映射到内存直接访问（适用于大文件）：

    ```c
    #include <sys/mman.h>
    char *data = mmap(file_fd, file_size, PROT_READ, MAP_PRIVATE, file_fd, 0);
    ```
3. **回调函数输入**  
    结合`fread`​的回调模式处理大数据流：

    ```c
    size_t read_callback(void *ptr, size_t size, size_t nmemb, void *userdata) {
        // 自定义读取逻辑
        return nmemb;
    }
    fread(buffer, size, nmemb, stdin, read_callback, userdata);
    ```

---

### 🚨 安全性警示

1. **缓冲区溢出**

    - **危险函数**：`gets`​、`sprintf`​、`strcpy`​等不检查边界
    - **安全替代**：

      ```c
      // gets → fgets
      fgets(buffer, sizeof(buffer), stdin);

      // sscanf → scanf_s
      scanf_s("%d", &num, sizeof(int));
      ```
2. **格式化字符串攻击**

    - 避免使用未经验证的用户输入作为格式化字符串：

      ```c
      // 危险代码！
      char input[100];
      scanf("%s", input); // 攻击者可注入`%n`导致溢出
      ```

---

### 📊 函数对比表

|函数|输入源|数据类型|安全性|适用场景|
| ------| ----------| ------------| --------| --------------------------|
|​`scanf`​|标准输入|格式化|低|简单数值输入|
|​`fgets`​|标准输入|字符串|高|行级文本输入|
|​`fread`​|文件/流|二进制|中|文件读写、二进制数据处理|
|​`getchar`​|标准输入|单字符|高|逐字符处理|
|​`sscanf`​|字符串|格式化|中|数据解析|
|​`getline`​|标准输入|动态字符串|高|需动态分配内存的场景|

---

### 💡 最佳实践

1. **优先选择安全函数**：

    - ​`fgets`​ \> `fgets_s`​ \> `scanf_s`​
    - 避免使用`gets`​、`strcat`​等危险函数
2. **缓冲区管理**：

    ```c
    // 安全读取用户输入
    char input[100];
    if (fgets(input, sizeof(input), stdin) == NULL) {
        perror("fgets");
        exit(1);
    }
    input[strcspn(input, "\n")] = '\0'; // 去除换行符
    ```
3. **二进制 vs 文本模式**：

    - 文件操作时显式指定模式：

      ```c
      FILE *fp = fopen("data.bin", "rb"); // 二进制模式
      ```
4. **跨平台兼容性**：

    - 使用`intptr_t`​处理指针类型：

      ```c
      intptr_t ptr = (intptr_t)malloc(100);
      ```

---

### 📜 总结

C语言输入方法可分为**格式化输入**、**字符级输入**、**行级输入**、**二进制输入**四大类，每种类型对应不同的函数和适用场景。开发者需根据具体需求选择安全高效的函数，并特别注意缓冲区管理和安全性问题。对于新手，建议从`fgets`​和`scanf_s`​入手，逐步掌握更复杂的输入处理技巧。

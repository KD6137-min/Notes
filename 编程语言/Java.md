# Java

# 一、概述

## JDK的安装目录

- bin: 该路径下存放了各种工具命令, 其中比较重要的有: javac和java
- conf: 该路径下存放了相关配置文件,
- include: 该路径下存放了一些平台特定的头文件,
- jmods: 该路径下存放了各种模块,
- legal: 该路径下存放了各模块的授权文档,
- lib: 该路径下存放了工具的一些补充JAR包

## 命令行编译

- 文件后缀.java

```bash
 javac HelloWorld.java //编译
 Java HelloWorld //运行, 无后缀
```

## Java发展

分为过渡版本和长期支持版本(LTS)

- 2004, java5.0
- 2014,  java8.0
- 2021,  java17.0

## 三大使用平台

- Java SE: 标准版, 用于桌面应用开发, 其他版本的基础
- Java ME: 小型版, 用于嵌入式电子设备获小型移动设备
- Java EE: 企业版, 用于Web方向网站开发

## 主要特性

- 面向对象
- 跨平台
- 开源
- 简单易用
- 多线程
- 安全性

## JDK和JRE

- JVM: Java虚拟机, 实际运行Java程序
- JDK: Java开发工具包
- JVM

  - 核心类库
  - 开发工具: javac编译工具、java运行工具、jdb调试工具、jhat内存分析工具
- JRE: Java的运行环境
- JVM

  - 核心类库
  - 运行工具**JDK包含JRE, JRE包含JVM**

‍

---

‍

# 二、基础语法

## 注释

不参与编译和运行, 书写时不要嵌套

```java
 //单行注释信息
 /*多行注释信息
 多行*/
 
 /**文档注释信息*/
```

## 关键字

全部小写class: 用于创建/定义一个类, 类是Java最基本的组成单元

- 字面量: 告诉程序员数据在程序中的书写格式
- 整数

  - 小数
  - 字符: 单引号
  - 字符串: 双引号
  - 布尔: ==boolean==, 与其他语言区别
  - 空: null, 一个特殊的值, 空值
  - 特殊字面量: 制表符\\t等

## 进制

不同进制表现形式

- 二进制: 0b开头
- 八进制: 0开头
- 十进制: 无前缀
- 十六进制: 0x开头

## 数据类型

- 基本数据类型

  - 整数

    - byte: 1字节, -128～127
    - short: 2字节
    - int: 4字节(默认)
    - long: 8字节, 数值后加l或L作后缀

  - 浮点数

    - float: 4字节, 数值后加f或F作后缀
    - double: 8字节(默认)
  - 字符
  - char: 2字节
  - 布尔boolean: 1字节取值范围大小

    > byte \< short \< int \< long \< float \< double
    >
- 引用数据类型: 值存储在其他空间中, 自己存储地址

  - 赋值时, 赋的是地址
    两个引用指向同一个对象: 

    ```java
     Student stu2 = stu1;    //指向堆中同一个对象, 不同与C++
    ```

## 标识符

规则: 

- 字母、数字、下划线\_、美元符\$组成
- 不能数字开头
- 不能是关键字
- 区分大小写

## 键盘录入

SCanner类, 接收键盘输入

```java
import java.util.Scanner; // 导包
Scanner sc = new Scanner(System.in); // 创建对象
```

- 第一套体系: 遇到空格、制表符、回车即停, 之后数据留在缓冲区

  ```java
  int i = sc.nextInt(); 		// 接收整数
  double d = sc.nextDouble(); // 接收浮点数
  String str = sc.next(); 	// 接收字符串
  ```

- 第二套体系: 遇到回车即停, 可以接收空格和制表符

  ```java
  String str = sc.nextLine(); // 接收字符串
  ```

两套体系不能混用, 若先用nextInt(),后用nextLine(), 导致nextLine()会先接收缓冲区中的空白符, 造成混乱

## 输出

```java
System.out.println("HelloWorld"); 	 //以换行符结尾
System.out.print("HelloWorld");		 //无结尾间隔符
```

## idea项目结构

- project--项目
- module--模块

  - package--包

    - class--类
- 代码样式

```java
 import class_name;
 package pack_name;
 
 public class class_name { //此处类名必需和文件名保持一致 
     //主入口
     public static void main(String[] args) { // psvm快捷键, 可快速生成主入口
         System.out.println("HelloWorld");
     }
 }
```

import只作用于package和class, 导入包中的类、接口或静态成员, 以便不写完整类名

导入整个包: 

```java
 import java.util.*;
```

java9开始, 模块通过`module-info.java`​文件进行管理, 不通过import: 

```java
 // module-info.java
 module my.module {
     exports com.myapp;           // 导出包
     requires java.base;          // 依赖其他模块
 }
```

## 运算符

- 隐式转换(自动类型提升): byte -\> short -\> int -\> long -\> float -\> double
- 小的提升为大大进行运算

  - byte、 short、 char三类运算时, ==两个操作数类型相同==, 也会提升为int再运算, 结果为int
- 强制转换: 前括号: (目标类型名)操作数
- 字符串的"+": +操作数中任一为字符串时, +变为字符串连接符(不再是算术运算符), 将前后数据拼接成新字符串

  - 连续+时, 从左到右逐个执行

  ```java
   "123" + 123 // "123123"
   1 + 99 + "年" // "100年" 
   1 + 2 + "abc" + 2 + 1 // "3abc21"
  ```
- 字符的"+": 字符+字符 或 字符+数字: 转换为ASCII对应数字进行运算, 结果为int类型
- 逻辑运算符

  - &逻辑与
  - ｜逻辑或
  - \^逻辑异或
  - ！逻辑非
- 短路逻辑运算符(更常用, 效率高)

  - &&短路与: 结果与&相同, 但是有段路效果
  - ||短路或: 结果与｜相同, 但是有段路效果
  - 【注意】: 

    - &和｜无论左边true、false, 右边都要执行
    - &&和||  若左边可确定表达式结果, 则右边不执行

## 流程控制语句

- 顺序结构
- 分支结构

  - if语句: 同C++
  - switch语句: 一般格式同C++

    - 新格式: 省略了break, C++没有

    ```java
     switch(number) {
         case 1 -> {
             System.out.println();
         } // 带大括号的版本
         case 2 -> System.out.println(); // 省略大括号的版本
         default -> System.out.println();
     }
    ```
- 循环结构

  - while
  - do{}while()
  - for

## 随机数

Random类

```java
 import java.util.Random;
 Random r = new Random();
 int num = r.nextInt(随机数范围); // 均从0开始, 到该参数-1, 即范围不包括结尾
 int number = r.nextInt(100) + 100; // 100～199
```

## 数组

- 存储同种类型值(可结合隐式转换)

  - int类型数组, 可放byte、short
  - double类型数组, 可放byte、short、int、long、float
- 两种格式

  - ```java
     int[] array; // 推荐格式
     int array[]; // 传统格式
    ```
  - 传统格式与推荐格式语法上等价
  - C++中数组实质为指向连续内存的指针, 而Java中int[]为一个特殊的对象类型, 是类名
- 数组静态初始化

```java
 int[] array = new int[]{1, 2, 3}; // 完整格式
 int[] array = {1, 2, 3}; // 简化格式
```

- 数组动态初始化(推荐)
  初始化时只指定长度

  ```java
   int[] array = new int[3];
  ```

  - 默认初始值

    - 整数类型, 默认值0
    - 浮点数, 默认值0.0
    - 字符, 默认值'/u0000'空格
    - 布尔类型, 默认值false
    - 引用数据类型, 默认null
- 数组的地址值: [D@776ec8df

  - [: 表示当前是一个数组
  - D: 表示当前数组中元素为double类型
  - @: 间隔符, 固定
  - 776ec8df: 数组真正的地址值, 十六进制
- 数组的长度: length, 不加括号

```java
 System.out.println(arr.length); 
```

- 数组的遍历: 快速生成方式: 数组名.fori  按tab  (idea提供)

‍

---

‍

# 三、类设计

一个java文件可定义多个class类, 只能有一个public, 该public类名必须为代码文件名

> 实际开发中还是一个文件定义一个class类

## Javabean类

用来描述一类事物的类, 该类不写main方法

> 写main方法的类称为`测试类`​

标准javabean类: 

- 成员变量都用private修饰
- 至少两个构造方法: 无参、带全部参数的构造方法
- 对于每个私有成员, 提供get和set方法

插件ptg, 一秒生成标准Javabean, 写完类名和成员变量后, 右键ptg to javabean

## this指针

就近原则: 变量同名, 优先找本作用域内的, 所以引入this指针, 区分成员变量和局部变量: 

- 隐式传递给`非静态成员函数`​的指针, 指向调用者的地址
- 常量指针(地址不可修改), 但指针本身不是常量
- 类静态成员函数不能用this
- this指针保存在调用栈的栈帧中, 调用时, 编译器隐式地将地址作为参数传递给函数
- 生命周期和调用栈帧相同

## 构造方法

构造方法: 空参构造、带参构造(重载)

未定义构造方法时, 系统给默认无参构造, 若有定义, 则不提供默认的构造方法(推荐自己再补上空参构造方法)

<u>无论是否使用, 都定义无参和有参两种构造方法</u>

## API

Application Programming Interface,应用程序编程接口

直接使用即可, 不需关心类如何实现

‍

---

‍

# 四、内存分配

## 分区

- 栈: 方法运行时使用, 如main方法, 开始执行时进栈, 完毕时出栈
- 堆: 存储对象或数组, new创建的都在堆中开辟空间并产生地址
- 方法区: 存储可运行的class文件(JDK8开始取消方法区, 新增元空间, 方法区功能拆分到堆和元空间中)
- 本地方法栈: JVM在使用OS功能时使用, 与开发无关
- 寄存器: 给CPU使用, 与开发无关
- 元空间

## 创建对象背后的工作

- 方法区加载class文件
- 栈中声明局部变量
- 堆中开辟一个空间
- 堆中该类型对象默认初始化(对象模型中包括一个指针指向函数表)
- 显式初始化
- 构造方法初始化
- 将堆内存地址赋值给栈中局部变量​​

|区别|成员变量|局部变量|
| --------------| ----------------------------| ----------------------------|
|类中位置不同|类中, 方法外|方法内, 方法声明上|
|初始化值不同|有默认初始化值|无, 使用前需赋值|
|内存位置不同|堆内存|栈内存|
|生命周期不同|对象创建即存, 对象消失即灭|方法调用即存, 方法结束即灭|
|作用域不同|整个类中有效|当前方法中有效|

‍

---

‍

# 五、java和C++区别

|**对比点**|**Java**|**C++**|
| --| --------------------------------------------| ----------------------------------------|
|**内存分配**|​`new`​创建对象, **自动垃圾回收**(JVM 自动管理对象内存)|​`new`​创建对象, **手动释放内存**(必须显式使用`delete`​释放内存)|
|**数组存储内容**|数组存储对象的引用(类似指针), |数组存储指针, 指向堆上的对象|
|**类型安全**|数组可以存储`Goods`​类型引用, 无需显式指定类型, |数组需要显式定义为`Goods*`​类型指针数组|
|**代码复杂度**|较简洁, 适合于高层次编程|更复杂, 但提供了更多的控制权|

## **Java 内存布局**

- 数组存储引用, 元素大小\=\=引用大小(4B或8B), 类对象大小与数组本身无关
  灵活, 但比C++多了间接访问开销

  ```
   // 声明一个 Goods 引用数组
   Goods[] arr = new Goods[3];
  
   // 创建三个商品对象
   Goods g1 = new Goods("001", "华为P40", 5999.0, 100);
   Goods g2 = new Goods("002", "保温杯", 227.0, 50);
   Goods g3 = new Goods("003", "枸杞", 12.7, 70);
  
   // 将对象放入数组
   arr[0] = g1;
   arr[1] = g2;
   arr[2] = g3;
  ```

  - arr --\> (堆)｜  [ 引用    |    引用   |    引用 ]     ｜ #  数组在堆中, 存储引用  ｜       ↓                ↓               ↓           ｜          ｜[Goods1] [Goods2] [Goods3]   ｜# 每个对象独立存储在堆中

## **C++ 内存布局**

- 对象数组在栈或堆中直接分配所有对象的内存空间, 元素大小\=\=类对象大小

  ```
   Goods* arr[3];
  
   arr[0] = new Goods("001", "华为P40", 5999.0, 100);
   arr[1] = new Goods("002", "保温杯", 227.0, 50);
   arr[2] = new Goods("003", "枸杞", 12.7, 70);
  ```

  - arr -- \>  (堆)  [ Goods1 | Goods2 | Goods3 ]  \<-- 对象数组直接存储对象内容
- 也可直接在栈上分配对象, 不用 `new`​, 更安全,  C++ 开发, 优先选择栈分配方式

  ```
   // 在栈上分配 Goods 对象数组
   Goods arr[3] = {
       Goods("001", "华为P40", 5999.0, 100),
       Goods("002", "保温杯", 227.0, 50),
       Goods("003", "枸杞", 12.7, 70)
   };
  ```

## 引用: 指针的抽象

java无显式指针, 没有 `&`​(取地址符)或 `*`​(解引用符), 防止开发者直接操作内存, 简化开发, 可移植性好

引用即一个"指向对象的安全指针"

‍

---

‍

# 六、String类

java.lang.String类, 核心库, 不需导包, 所有字符串均为此类对象

> 字符串内容不会改变, 对象创建后不能更改

## 两种创建方式

- 直接赋值: 字符串放入堆中的`字符串常量池`​中(串池)

  串池: 便于重用相同的字符串对象, 减少内存浪费

  直接赋值时, 系统检查串池中是否存在, 有则复用, 无则创建

  ```java
  String s1 = "hello";  // s在栈中, 值为引用, 指向堆中串池
  ```

- new构造: 在堆中开辟内存(非串池)

  ```java
  public String() 				// 创建空白字符串, 不含任何内容
  String s2 = new String(); 		// ""
  
  public String(String original) 	// 根据传入的字符串创建字符串
  String s3 = new String("abc");  // new操作实际上未执行, 跳过了
  public String(char[] chs) 		// 根据字符数组创建字符串
      char[] chs = {'a', 'b', 'c', 'd'};
  String s4 = new String(chs); 	// "abcd"
  
  public String(byte[] chs) 		// 根据字节数组创建字符串, 会将字节转换为字符串
      byte[] bytes = {97, 98, 99, 100};
  String s5 = new String(bytes); 	// "abcd"

  ![截屏2024-12-14 22.40.38](../assets/截屏2024-12-14%2022.40.38-20241214224045-7ythvid.png)

  > String str = sc.next();也是new构造出来, next()方法背后使用new
  >

## 字符串比较

- `==`: 

  - 对于基本数据类型, 比较数据值
  - 对引用数据类型, 比较地址值
  - 直接赋值的和new出来的`==`一定为false
- boolean equals方法(待比较字符串): 完全一样为true
- boolean equalsIgnoreCase(待比较字符串): 忽略大小写

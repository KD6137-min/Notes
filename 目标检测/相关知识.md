

# **选择性搜索**

Selective Search，快速地从图像中提取可能包含物体的候选区域，通过模仿人类的视觉系统，采用**自底向上**的策略，将小的、相似的区域逐步合并成大的、可能包含物体的区域

### 核心思想

1. **分层分组**：从像素级开始，将相似的区域逐步合并成更大的区域
2. **多样化策略**：使用**多种互补的相似度度量**（颜色、纹理、大小、拟合度）来确保无论何种物体都能被成功提议

### 具体过程

#### 第1步：生成初始区域

使用一种图像分割算法（如**Felzenszwalb和Huttenlocher的基于图的分割方法**）对输入图像进行初始化分割，将图像分割成很多个小的、不规则的**“超像素”区域**，这些区域内部颜色、纹理相对均匀，得到一组初始区域集合 R={r1,r2,...,rn}，这些区域是后续合并操作的起点

#### 第2步：计算区域间的相似度

对于所有相邻的区域对，计算它们的相似度$s(r_i,r_j)$

四种互补的相似度度量：

1. **颜色相似度（Colour Similarity）**：为每个区域计算一个颜色直方图（通常每个颜色通道25bins，共75维），计算两个区域颜色直方图的交集，作为相似度，直方图越相似得分越高，$S_{colour}(r_i,r_j) = \sum_{k=1}^nmin(c_i^k,c_j^k)$，其中$c_i^k$是区域 $r_i$的颜色直方图中第k个bin的值
2. **纹理相似度（Texture Similarity）**：计算每个区域的纹理特征（如使用高斯导数提取SIFT-like特征并生成纹理直方图），同样计算两个直方图的交集，$s_{texture}(r_i,r_j)=\sum_{k=1}^nmin(t_i^k,t_j^k)$
3. **大小相似度（Size Similarity）**：鼓励小的区域优先合并，避免一个大区域逐个“吞噬”所有小区域，从而保持多尺度，$s_{size}(r_i,r_j)=1-\frac{size(r_i)+size(r_j)}{size(image)}$，区域越小则大小相似度得分越高，当两个小区域合并时此值较大；当一个巨大区域和一个小区域合并时此值很小
4. **拟合相似度（Shape Compatibility Similarity）**：衡量两个区域合并后形成的“新区域”的拟合程度（是否紧密）
    - **填充相似度（Fill Similarity）**：衡量合并后的Bounding Box（外接矩形）有多大比例没有被两个原始区域填充，$s_{fill}(r_i,r_j)=1-\frac{size(BB_{ij})-size(r_i)-size(r_j)}{size(image)}$，如果两个区域能完美拟合在一起（比如一块拼图），它们合并后占用的额外空间就小，该得分就高
    - **其他形状度量**（如实际轮廓拟合度）

**最终的总相似度**是这四种相似度的加权和（通常权重设为1）：$s(r_i,r_j)=s_{colour}(r_i,r_j)+s_{texture}(r_i,r_j)+s_{size}(r_i,r_j)+s_{fill}(r_i,r_j)$

#### 第3步：合并最相似的区域

将所有相邻区域对的相似度存入一个优先队列（通常是最**大堆**，按相似度从高到低排序），取出**相似度最高**的区域对 (ri,rj)，将这两个区域从当前集合中移除，并合并成一个新区域，$r_t=r_i \cup r_j$，添加新区域 $r_t$

这个队列中存放的是**数据条目**，每个条目通常包含：

1. **相似度得分（Score/Priority）**：这是堆进行排序的**键（Key）**，堆根据这个值来维护结构，确保堆顶的元素永远是当前所有区域对中相似度最高的
2. **区域对的标识（Value）**：这是条目的**值（Value）**，用于记录这个相似度得分对应的是哪两个区域（“碎片”），通常是用两个区域的索引 `(index_i, index_j)` 来表示

#### 第4步：更新相似度

新区域 rt 形成后，需要计算它与所有**与之相邻**的区域的相似度，将这些新的相似度对加入到优先队列中

#### 第5步：循环与输出

重复步骤3和4，直到整个优先队列为空（即所有区域都合并成了一整张图）

#### **输出**：

在**每一次合并步骤中**，都会生成新的、更大的区域，算法会将这些在合并过程中产生的**所有区域**（从初始小区域到最终的大区域）的边界框（Bounding Box）都收集起来，作为候选区域提议

### 后处理与多样化

1. **去除重复**：使用非极大值抑制（NMS）来移除高度重叠的候选框，只保留最具代表性的一个
2. **多样化策略（关键创新）**：为了应对不同特性的物体（比如一个绿色的球和一个绿色的恐龙），算法会在**不同的颜色空间**（如RGB, HSV, Lab）中，**使用不同的相似度度量权重**，**并行地**运行多次上述过程，最后将所有结果汇总，再经过NMS，得到最终的候选区域列表，这确保了提议的多样性

### 快速模式

高质量模式即标准、完整的搜索过程，追求尽可能高的召回率但计算速度较慢

快速模式**通过牺牲一定的召回率来极大地提升生成区域提议速度**

**实现策略：**

- 限制初始分割的“粒度”：
    - 标准模式使用基于图的分割算法时，会设置一个较小的 `k`（或 `sigma`）参数，导致生成大量、精细的初始小区域（超像素），这意味着后续有海量的区域对需要计算相似度和合并
    - **快速模式**增大分割算法的 `k` 参数，这会导致初始分割产生**更少、更大的“碎片”**（初始区域），使初始区域数量（N）大幅减少，后续合并的步骤也相应减少，整个算法的计算量急剧下降
- 减少相似度度量的多样性：
    - 标准模式为了最大化召回各种不同的物体，算法会在**多个颜色空间**（如RGB, HSV, Lab）中，使用**多种相似度度量组合**（改变颜色、纹理、大小等权重的组合）并行地运行多次选择性搜索流程，最后合并所有结果，这相当于同时运行了K个独立的选择性搜索实例
    - **快速模式**：**只使用一种配置**（例如，仅在RGB颜色空间下，使用一组固定的相似度权重）运行**一次**选择性搜索流程，计算量直接减少为原来的 ~1/K（K是并行运行的配置数量）


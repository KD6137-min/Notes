# 面向对象

将程序中的数据和行为封装在一起, 以对象的形式表示，Python中一切皆对象

**类与对象的关系：**

- `is-a`：继承/泛化关系
- `has-a`：关联关系
    - 聚合关系：整体和部分，部分可以独立存在
    - 合成关系：最强的关联关系，整体和部分同时存在，同时消亡
- `use-a`：依赖关系



## 类

对象的模版, 元类的实例

### 类属性

直接定义在类中, 被所有对象所共有, 对象、类均可调用, **只能通过类修改**

```python
class Student:
    school = '北科大'	# 类属性
    count = 0		  # 类属性
    
    def __init__(self, name):
        self.name = name	# 实例属性
        Student.count += 1	# 修改类属性
```

**`__slot__`槽**：特殊类属性，一种**内存和属性管理机制**, 内存优化工具, 用于限制类实例可动态添加的属性数量, 修改了类的内部结构(不涉及对象行为的约定, 不是协议)

- **限制动态属性:** 类实例只能拥有slot中指定的属性, 但仍可通过`__dict__`​强制添加(不推荐)

  ```python
  class MyClass:
      __slots__ = ['name', 'age']
  
  obj = MyClass()
  obj.y = 42 # 报错
  obj.__dict__['y'] = 42 # 强制添加，不推荐
  ```
- 节省内存: Python对象默认有一个`__dict__`​属性用于存储动态添加的属性, `__slot__`​移除了`__dict__`​, 减少了内存开销, 也因此提高了属性的访问速度
- 注意: `@property`​装饰器装饰的是方法, 因此不打破slot的限制, 实际可用@property装饰一个计算属性(使用已有属性计算得出)

### 类方法

不访问对象属性/方法, 只访问类属性的方法, 影响所有实例，用**`@classmethod`**​装饰器修饰，定义时第一个参数是**cls, 当前类**

```python
class Counter:
    count = 0
    
    @classmethod
    def increment(cls):
        cls.count += 1
        
    @classmethod
    def get_count(cls):
        return cls.count
    
# 调用方式
Counter.increment()	# 通过类名调用，推荐，节约内存
obj = Counter()
obj.increment()	# 可通过实例调用
```

### 静态方法

独立的功能函数，与类、对象无直接关系, 不访问对象属性/方法或类属性的方法，用**`@staticmethod`​**装饰器修饰，仅写在类中, 无self/cls形参，不调用其他方法, 只能调用类的静态成员

```python
class MathUtils:
    @staticmethod
    def add(a, b):
        return a + b
    
    @staticmethod
    def is_prime(n):
        if n < 2:
            return False
        for i in range(2, int(n ** 0.5) + 1):
            if n % i == 0:
                return False
        return True

# 调用方式
result = MathUtils.add(1, 2)  # 通过类名调用
obj = MathUtils()
result = obj.add(1, 2)        # 通过实例调用
```

## 对象

类的实例

### 实例属性

随着对象创建而创建, 随着对象消失而消失, 多个对象之间相互独立, 互不干扰, 只能对象调用, 类不能调用

```python
class Person:
    def __init__(self, name, age):
        self.name = name      # 公有属性
        self.__age = age      # 私有属性
        self._height = 170    # 受保护属性（约定）
```

**实例属性与类属性分离:** 给对象添加新属性不会直接影响类属性, 新属性存储在实例的`__dict__`中, 其他同类实例不受影响，实例属性会"隐藏"同名的类属性, 但不会修改类属性本身

### 私有属性

通过名称修饰(加`__`)实现，**并非强制**, 只是提示调用者, 只希望在对象内部被使用, 不希望外部使用，且不影响子类的继承，本质是在内部对其名称添加了`_classname`前缀

```python
class Person:
    def  __init__(self, name): 
        # 私有属性
        self.__age = 18 
        self.name = name

    # 定义方法访问私有属性
    def secret(self): 
        print(self.__age)

    # 私有方法
    def _secret(self): 
        print(self.__age)
        
jack = Person()
print(jack.__age)	# 报错
print(jack._secret())
print(jack._Person__age)	# 用._classname__attr 强制访问，不推荐
```

> [!note]
>
> **Python原则:** 开放比封闭要好, 'We are all consenting adults here', 我们应该自己对自己的行为负责而不是从语言层面来限制对数据或方法的访问

### 属性访问控制

- 传统**getter/setter**方式：

    ```python
    class Temperature:
        def __init__(self):
            self.__celsius = 0
            
        def get_celsius(self):
            return self.__celsius
        
        def set_celsius(self, value):
            if value < -273.15:
                raise ValueError('温度不能低于绝对零度')
            self.__celsius = value
    ```

- Property装饰器方式：`@property`修饰

    ```python
    class Temperature:
        def __init__(self):
            self.__celsius = 0
        
        @property
        def celsius(self):		# 属性getter，只读
            return self.__celsius
        
        @celsius.setter
        def celsius(self, value):	# 属性setter，可添加验证逻辑
            if value < -273.15:
                raise ValueError("温度不能低于绝对零度")
            self.__celsius = value
        
        @celsius.deleter	# 属性deleter
        def celsius(self):
            self.__celsius = 0
        
        @property
        def fahrenheit(self):	# 基于celsius的计算属性
            return self.__celsius * 9/5 + 32
    
    temp = Temperature()
    temp.celsius = 25
    print(temp.fahrenheit)  # 77.0
    ```

### 属性查找机制

**优先级顺序：**

1. **数据描述符**：若属性是**描述符对象**, 查找机制会被增强，描述符的 `__get__` 方法会被自动调用, 传入实例和类对象(`self`, `instance`, `klass`)

    ```python
    class Descriptor:
        def __get__(self, instance, klass):
            return f"Descriptor value for {klass.__name__}"
    
    class MyClass:
        attr = Descriptor()
    
    obj = MyClass()
    print(obj.attr)  # 输出 "Descriptor value for MyClass"
    ```

2. **实例属性**：检查实例自身的 **`__dict__`​ / `__slots__`**

3. **类属性**：若实例属性不存在, 则查找类对象的 **`__dict__`**​ 字典，包括显式定义的类属性、方法、以及通过 `@property`​ 等装饰器定义的属性

4. **超类链**：若类属性不存在, 按继承顺序(MRO)向上遍历父类(通过 **`__bases__`**​), 直到找到属性或到达基类 `object`​

5. **`__getattr__`**方法：兜底，找不到时触发，若无，则抛`AttributeError`查找失败

    - 类也可以定义 `__getattr__`, 但需要通过元类或 `@classmethod` 实现

    - 可添加虚拟属性：绕开slots限制，虽没地方存x属性，但可在`__getattr__`中计算/映射出一个x，如从别的字段派生/做懒加载，

        > 典型做法：`__slots__ = ('_data', ...)`，`__getattr__`查`_data`映射返回

    - ≠ 内置函数`getattr`：

        ```python
        getattr(obj, 'x'[, default])	# 按属性查找机制执行一次属性访问，可提供default避免抛错
        ```

### 实例方法

第一个参数为**self, 当前对象**(显式传递self, 明确性, 可读性, 灵活性, 避免了隐式行为, 支持多继承)

**特殊方法:**

- `__new__()`: 构造方法, 实例化对象, 是`类方法`​，需要返回一个实例，将该实例传递给`__init__`​的self参数
- `__init__()`: 对象方法，初始化方法, 给对象添加属性并进行赋值, 一参必为self，其他参数与`__new__`​保持一致, 不允许有返回值
- `__del__()`: 析构方法, 触发时机: 对象无引用(引用计数器为0, 若还有引用过, 则在所有代码执行结束的最后调用)、程序结束、对象被销毁
- `__call__()`: 对象方法，定义一个对象作为函数调用时的行为, 即用()调用时, 触发该对象的`__call__()`​方法

## 面向对象三大特性

### 封装性

**约定性**而非强制性，将数据和操作数据的方法结合在一起，隐藏对象的内部实现细节，提供访问控制

### 继承性

`子类(父类)`​

- object类是所有类的父类
- 子类直接继承父类的非私有属性、方法, 不可继承父类的私有属性、方法
- 多继承：继承多个父类`class 子类名(父类1,  父类2...):`​, 继承级别从左到右降低, 若父类有相同成员方法或成员变量, 优先继承左父类

```python
class Flyable:
    def fly(self):
        print("正在飞行")

class Swimmable:
    def swim(self):
        print("正在游泳")

class Duck(Animal, Flyable, Swimmable):
    def __init__(self, name):
        super().__init__(name)
    
    def speak(self):
        return f"{self.name} 嘎嘎叫"

duck = Duck("唐老鸭")
duck.fly()    # 来自Flyable
duck.swim()   # 来自Swimmable
duck.move()   # 来自Animal
```

#### `super()`

或`super(A, self)`旧写法: 查找和调用**继承链**中的下一个类的方法

- `A`: 以`A`​为锚点, 查找**下一个父类**, 并且调用该父类的`__init__`​方法
- `self`: 当前实例, `super()`​以此找到正确的上下文

- 若父类的初始化方法中未使用`super()`​, 会断掉继承链的初始化, 只调用第一个父类的初始化方法, 建议在所有的地方都使用`super()`​

```python
class A:
    def __init__(self):
        print("A's __init__ called")
        super().__init__() # ②调用A的__init__后, 该super仍基于C的MRO, 调用A之后的父类

class B:
    def __init__(self):
        print("B's __init__ called")
        super().__init__() # ③调用后, 调用object的__init__(无操作)

class C(A, B):
    def __init__(self):
        print("C's __init__ called")
        super().__init__() # ①根据C的MRO, 调用A的__init__
```

- 抽象类: 不能创建对象, 专门用于被继承, Python没有从语法层面支持抽象类

    - `继承ABC类`​和`@abstractmethod`​装饰器标记抽象方法, 两条件缺一不可

        - @abstractmethod用于标记抽象方法，表示子类必须实现此方法，但仅用`@abstractmethod`​无法定义抽象类, 类仍可实例化
        - 继承ABC使类成为抽象基类，在子类实例化时检查所有抽象方法是否实现
    - 多继承时必须显示调用super(), 确保元类冲突被正确处理
    - ABC和ABCMeta的区别：ABC继承自ABCMeta，内置支持注册虚拟子类，继承ABC即可定义抽象基类，无需显式指定metaclass=ABCMeta, 现代Python推荐继承ABC

    ```python
    from abc import ABCMeta, abstractmethod
    
    class Fighter(object, metaclass=ABCMeta):
    	@abstractmethod
    	def beat():
    		pass
    ```

### 多态性

不同子类调用同一父类方法时, 都调用对象私有方法(即用不同方式实现的父类方法)

支持鸭子类型测试: python不检查是否继承同一父类, 只要方法相同, 就是多态的

- 重写override: 

    - 父子属性不同: 重新初始化

        ```python
        def __init__(self, 公共属性, 新属性):
        	super().__init__(公共属性) 	# 继承公共属性
            self.新属性 = 新属性值
        ```

    - 父子方法不同: 在子类中定义方法, 只有子类可以调用, 若方法名相同, 子类覆盖父类方法

####

## 新式类

new-style classes，继承了 `object`​ 类的类，引入于 Python 2.2 版本, 并成为 Python 3 中的默认类类型，比旧式类(classic classes)具有更多的功能和特性, 特别是在面向对象编程方面

所有类在 Python 3 中都默认是新式类

### 新式类特点: 

1. **继承自** **​`object`​**:新式类必须直接或间接地继承自 `object`​
2. **支持** **​`super()`​** :新式类支持使用 `super()`​ 来调用父类的方法。`super()`​ 可以简化多重继承中的方法调用, 并且不会重复调用父类的方法
3. **改进的**  **​`__mro__`​** ​  **(方法解析顺序)** :新式类使用一种更加明确和一致的方法解析顺序(MRO)
4. **支持描述符协议**:新式类支持 Python 的描述符协议, 允许通过定义 `__get__`​、`__set__`​ 和 `__delete__`​ 方法来控制属性的访问
5. **属性和方法的改进**:新式类对方法和属性的管理更加灵活和一致, 比如使用 `@property`​ 装饰器来创建属性

在 **Python 2** 中, 只有显式继承 `object`​ 的类才是新式类, 否则默认是旧式类

```python
class MyClass(object):  # 这是新式类
    pass

class OldClass:  # 这是旧式类
    pass
```

在 Python 2 中, 新式类和旧式类在某些行为上有所不同, 最显著的是新式类支持 `super()`​ 和多重继承中的方法解析顺序(MRO)

## ‍MRO

Method Resolution Order，方法解析顺序，只读, 存储C3线性化计算的结果

当一个方法被调用时, Python 会从当前类开始, 逐步向上查找父类, 直到找到该方法为止

- `L[MyClass(Base1, Base2)] = MyClass + merge(L[Base1], L[Base2], Base1, Base2)`​, 即一个类的线性化为本类、父类的线性化、父类列表的合并的总和
- `类名.mro()`​或`类名.__mro__`​查看

**MRO 计算规则:** 

1. **深度优先遍历**: 从当前类开始向上查找, 查找的顺序通常是从左到右, 逐级向父类查找
2. **遵循 C3 线性化规则** : C3 线性化规则保证子类的父类顺序不改变、保证多继承时父类的顺序是根据类的继承结构自动计算出来的、保证继承关系的"合理性"即不允许父类间出现冲突
    1. **选择最左边且没有父类冲突的父类**: 首先从当前类的父类中, 选择最左边且没有与其他父类发生冲突的类
    2. **排除已经选中的父类**: 选择一个父类后, 排除它和它的所有父类, 不再选择它们
    3. **重复上述步骤**: 直到所有父类都被选中, 得到最终的 MRO 顺序

### 通过 `super()`​ 使用 MRO

`super()`，内置函数, 用于调用父类的方法或属性函数在多重继承中会按照 MRO 顺序调用父类的方法

- Python 3 中的 `super()`​：可不带任何参数, 自动使用当前类和当前实例
- Python 2 中的 `super()`​：需要传递当前类和当前实例

注意super不是调用当前类的父类，而是调用MRO中当前类的下一个类，这个MRO在第一次调用super时确定，确定终点后，执行init并按调用栈顺序逐步回退





## 元类

类的模版, 定义类的创建方式、行为和限制, 决定类本身的行为, 类定义中使用metaclass参数, 声明使用哪个元类

type是所有元类的父类, 用来定义和创建类，是一个元类，且为**默认的元类**

type是object的子类，object是type的一个实例，type的类型是type

![截屏2025-04-07 09.27.25](../assets/截屏2025-04-07%2009.27.25-20250407092728-rokq9io.png)

‍

![截屏2025-01-16 09.20.33](../assets/截屏2025-01-16%2009.20.33-20250116092037-hc8h29l.png)​​

```python
# 定义一个元类
class MyMeta(type):
    # 在类被创建之前, 可以修改类的属性
	def __new__(cls, name, bases, dct):
		dct['attr'] = 'Hello from Meta'
        return super().__new__(cls, name, bases, attrs)

# 通过元类(模具制造机)生成一个类(模具)
Dog = type('Dog', (object,), {'speak': lambda self: 'Woof!'})

# 生成一个对象(饼干)
dog = Dog()
print(dog.speak())  # 输出: 'Woof!'
```

### 元类钩子

定义元类的关键方法，用于自定义类的生成逻辑

- `__new__(cls, name, bases, dct)`: 创建类, 并控制类的结构, 核心方法

  - cls当前元类, name类名, bases父类元组, 包含所有正在创建类的父类, dct类的属性和方法字典
- `__init__(cls, name, bases, dict)`: 初始化类, new之后额外配置类属性或行为，元类的__init__主要用于类级别的验证/注入逻辑

  - cls：当前正被初始化的类，即元类的实例
  - name：类名
  - bases：类的父类元组
  - dict：类的属性和方法字典
- `__call__(cls, *args, **kwargs)`: 控制如何实例化类, `dog = Dog()`​就是触发了call方法
- `__prepare__(cls, name, bases)`: new之前准备类字典, 定制类定义过程

  ```python
  # 改变类属性的定义顺序
  from collections import OrderedDict
  
  class MyMeta(type):
  	def __prepare__(cls, name, bases):
  		return OrderedDict()
  
  	def __new__(cls, name, bases, dct):
  		print(dct)	# 输出OrderedDict()
  		return super().__new__(cls, name, bases, dct)
  ```

一个对象的创建过程：

![截屏2025-04-07 09.30.47](../assets/截屏2025-04-07%2009.30.47-20250407093049-6uvfs19.png)

### 单例模式

```python
class SingletonMeta(type):
    """
    元类, 用于实现单例模式
    """
	def __init__(cls, *args, **kwargs):
		cls.__instance = None		# 用于存储类的唯一实例
		cls.__lock = threading.RLock()
		super().__init__(*args, **kwargs)

    def __call__(cls, *args, **kwargs):
        """
        控制类的实例化逻辑
        """
        if cls.__instance is None:  # 如果实例不存在, 创建新实例并保存
			with cls.__lock():
				if cls.__instance is None:
					cls.__instance = super().__call__(*args, **kwargs)
        return cls.__instances


class SingletonClass(metaclass=SingletonMeta):
    """
    使用 SingletonMeta 作为元类的类
    """
    def __init__(self, value):
        self.value = value


# 测试单例模式
obj1 = SingletonClass(42)
obj2 = SingletonClass(99)

print(obj1 is obj2)  # 输出 True, 表示两个对象是同一个实例
print(obj1.value)   # 输出 42, 值与第一次实例化时相同
print(obj2.value)   # 输出 42
```

核心思想: 使用元类的`__call__`​方法, 控制类实例的创建, 如果已经存在实例(对象), 则返回现有的实例, 否则创建一个新实例

使用场景: 

- 资源共享: 例如数据库连接池、线程池
- 配置管理: 系统配置、全局配置管理器
- 日志管理: 确保日志对象在整个应用中唯一

> 注意事项：Python 2 中元类定义语法不同: `class MyClass(base_class): __metaclass__ = MyMeta`​，Python 3 统一使用 `metaclass=MyMeta`​



# Mixin混入

一种编程范式, 主要用于**类的继承**(将额外功能注入目标类), 允许将多个功能模块化(只实现一个/一组功能), 并将它们'混入'到其他类(常与多继承一起使用)中, 从而实现**代码复用**和**功能扩展**, 不设计为独立的类实例, 不存储状态

```python
# 提供驾驶功能的Mixin类
class DrivableMixin:
    def drive(self):
        print(f'{self.__class__.__name__} is driving.')


# 提供加速功能的Mixin类
class AcceleratableMixin:
    def accelerate(self):
        print(f'{self.__class__.__name__} is accelerating.')


# 目标类, 将Drivable和Acceleratable的功能'混入'到自己身上
class Car(DrivableMixin, AcceleratableMixin):
    def __init__(self, brand):
        self.brand = brand

car = Car('Toyota')
car.drive()         # 输出: Car is driving.
car.accelerate()    # 输出: Car is accelerating.
```

注意:

- 避免状态管理: Mixin不应管理状态或依赖于实例变量, 其目的是提供方法, 而非持有数据
- 避免命名冲突: 多个Mixin可能会提供同名的方法或属性, 设计时需避免命名冲突

  - Python的方法解析顺序(MRO)决定多个类有相同方法时, 哪个方法优先执行
- 避免滥用多继承: Mixin可帮助分割, 但易让类的继承结构变复杂(尤其是多个Mixin嵌套)
- 保持接口一致性: 在不同类中混入多个Mixin时, 应确保其接口一致, 避免不同Mixin之间产生矛盾或依赖关系

```python
# 自定义字典限制只有在指定的key不存在时才能在字典中设置键值对
class SetOnceMappingMixin:
    """自定义混入类"""
    __slots__ = ()

    def __setitem__(self, key, value):
        if key in self:
            raise KeyError(str(key) + ' already set')
        return super().__setitem__(key, value)


class SetOnceDict(SetOnceMappingMixin, dict):
    """自定义字典"""
    pass


my_dict= SetOnceDict()
try:
    my_dict['username'] = 'jackfrued'
    my_dict['username'] = 'hellokitty'
except KeyError:
    pass
print(my_dict)
```

# 面向对象设计原则

- SOLID原则

  - 单一职责原则(SRP): 一个类只负责一个职责或一个功能, 这个原则强调的是**高内聚**、低耦合, 可以降低类的复杂度, 提高代码的可读性、可维护性和可重用性
  - 开闭原则(OCP): 一个类的行为应该是**可扩展**的, 但是**不可修改**, 这个原则强调的是代码的可维护性和可扩展性, 通过抽象化来避免修改已有代码的风险, 从而降低软件维护的成本
  - 里氏替换原则(LSP): 子类应该可以替换其父类并且不会影响程序的正确性, 这个原则强调的是面向对象的继承和多态特性, 通过保证子类的行为和父类一致, 从而提高代码的可维护性和可扩展性
  - 接口隔离原则(ISP): 一个类不应该依赖它不需要的接口, 即一个类对其它类的依赖应该建立在最小的接口上, 这个原则强调的是接口设计的合理性, 避免不必要的接口导致类之间的耦合性过高, 从而提高代码的灵活性和可维护性
  - 依赖倒置原则(DIP): **依赖于抽象**而不是依赖于具体实现, 这个原则强调的是代码的可扩展性和可维护性, 通过抽象化来减少组件之间的耦合性, 从而使得代码更加灵活、易于维护和扩展
  - SOLID原则的扩展: 

    - KISS原则: Keep It Simple, Stupid, 系统设计应该保持简单, 避免不必要的复杂性
    - YAGNI原则: You Aren't Gonna Need It, 不要为将来可能需要的功能过度设计或预先实现, 专注于当前需求, 避免浪费时间和资源

- 迪米特法则(LoD): 也叫最少知识原则(LKP), 一个对象应当对其他对象有尽可能少的了解, 不需要了解的内容尽量不要去了解, 这个原则强调的是组件之间的松耦合, 通过减少组件之间的依赖关系, 提高代码的可维护性和可重用性
- 组合/聚合复用原则(CARP): 尽量使用组合或聚合关系, 而不是继承关系来达到代码复用的目的, 这个原则强调的是通过组合和聚合的方式来实现代码复用, 避免继承带来的一些问题, 如父类和子类之间的强耦合性, 从而提高代码的灵活性和可维护性

# GoF设计模式

设计模式: 指一套被广泛接受的、可重复使用的软件设计解决方案

23种, 三类

## 创建型模式

涉及对象的创建机制, 并提供了一种**将对象的创建和使用分离**的方式

- 工厂模式: 定义一个创建对象的接口, 让子类决定实例化哪一个类, 工厂方法使一个类的实例化延迟到其子类
- 抽象工厂模式: 提供一个创建一系列相关或相互依赖对象的接口, 而无需指定它们的具体类
- 单例模式: 确保一个类只有一个实例, 并提供对该实例的全局访问点
- 建造者模式: 将一个复杂对象的构建与它的表示分离, 使得同样的构建过程可以创建不同的表示
- 原型模式: 通过复制现有的实例来创建新的对象, 而不是使用构造函数

## 结构型模式

涉及将类或对象组合在一起形成更大的结构, 并提供了一种简化设计的方式

- 适配器模式: 将一个类的接口转换成客户希望的另一个接口, 适配器模式可以让原本由于接口不兼容而不能在一起工作的类可以一起工作
- 桥接模式: 将抽象部分与它的实现部分分离, 使它们都可以独立地变化
- 组合模式: 将对象组合成树形结构以表示部分-整体的层次结构 组合模式使得用户对单个对象和组合对象的使用具有一致性
- 装饰器模式: 动态地将责任附加到对象上, 提供了一种灵活的替代继承的方式
- 外观模式/门面模式: 为子系统中的一组接口提供一个一致的界面, 使得子系统更容易使用
- 享元模式: 运用共享技术来有效地支持大量细粒度对象的复用
- 代理模式: 为其他对象提供一种代理以控制对这个对象的访问, 代理对象可以在被代理对象执行操作前后进行一些预处理和后处理

## 行为型模式

涉及对象之间的通信和算法的分配, 并提供了一种实现松散耦合的方式

- 责任链模式: 为解除请求的发送者和接收者之间耦合, 而使多个对象都有机会处理这个请求
- 命令模式: 将请求封装成一个对象, 从而使你可以用不同的请求对客户进行参数化, 命令模式也支持撤销操作
- 解释器模式: 是一种行为型设计模式, 它提供了一种方法, 可以在运行时解释语言文法中的表达式, 并执行相应的操作
- 迭代器模式: 提供一种方法顺序访问一个聚合对象中的各个元素, 而又不暴露该对象的内部表示
- 中介者模式: 用一个中介对象来封装一系列的对象交互, 中介者使各个对象不需要显式地相互作用, 从而使其耦合松散, 而且可以独立地改变它们之间的交互
- 备忘录模式: 在不破坏封装性的前提下, 捕获一个对象的内部状态, 并在该对象之外保存这个状态, 备忘录模式可以在需要时将对象恢复到先前的状态
- 观察者模式: 定义对象间的一种一对多的依赖关系, 使得每当一个对象状态发生改变时, 所有依赖它的对象都会得到通知并自动更新
- 状态模式: 允许对象在其内部状态发生改变时改变它的行为, 对象看起来似乎修改了它的类
- 策略模式: 定义一系列算法, 将每个算法都封装起来, 并使它们之间可以互换, 使得算法可以独立于使用它的客户而变化

  ```python
  # 可插拔的哈希算法
  class StreamHasher:
      """哈希摘要生成器"""
  
      def __init__(self, alg='md5', size=4096):
          self.size = size
          alg = alg.lower()
          self.hasher = getattr(__import__('hashlib'), alg.lower())()
  
      def __call__(self, stream):
          return self.to_digest(stream)
  
      def to_digest(self, stream):
          """生成十六进制形式的摘要"""
          for buf in iter(lambda: stream.read(self.size), b''):
              self.hasher.update(buf)
          return self.hasher.hexdigest()
  
  def main():
      """主函数"""
      hasher1 = StreamHasher()
      with open('Python-3.7.6.tgz', 'rb') as stream:
          print(hasher1.to_digest(stream))
      hasher2 = StreamHasher('sha1')
      with open('Python-3.7.6.tgz', 'rb') as stream:
          print(hasher2(stream))
          
  if __name__ == '__main__':
      main()

- 模板方法模式: 定义一个算法框架, 并将一些步骤延迟到子类中实现, 以便在不改变算法结构的情况下, 允许子类重定义算法的某些步骤
- 访问者模式: 是一种行为型设计模式, 它可以让你在不修改对象结构的前提下, 定义作用于这些对象元素的新操作



# 单例模式

单例模式(Singleton Pattern)是一种设计模式, 确保一个类只有一个实例, 并提供一个全局访问点。下面是几种在 Python 中实现单例模式的常见方法。

### 1. 使用模块

在 Python 中, 模块是单例的, 因为在程序运行时, 一个模块只会被加载一次。如果需要实现单例模式, 可以直接使用模块: 

```python
# singleton.py
class Singleton:
    def some_business_logic(self):
        pass

singleton_instance = Singleton()
```

在其他模块中你可以这样访问: 

```python
# another_module.py
from singleton import singleton_instance

singleton_instance.some_business_logic()
```

### 2. 使用类属性

```python
class Singleton:
    _instance = None

    def __new__(cls, *args, **kwargs):
        if not cls._instance:
            cls._instance = super(Singleton, cls).__new__(cls)
        return cls._instance

# 测试
s1 = Singleton()
s2 = Singleton()

print(s1 is s2)  # 输出: True
```

### 3. 使用装饰器

```python
def singleton(cls):
    instances = {}

    def get_instance(*args, **kwargs):
        if cls not in instances:
            instances[cls] = cls(*args, **kwargs)
        return instances[cls]

    return get_instance

@singleton
class Singleton:
    def some_business_logic(self):
        pass

# 测试
s1 = Singleton()
s2 = Singleton()

print(s1 is s2)  # 输出: True
```

### 4. 使用元类

```python
class SingletonMeta(type):
    _instances = {}

    def __call__(cls, *args, **kwargs):
        if cls not in cls._instances:
            cls._instances[cls] = super(SingletonMeta, cls).__call__(*args, **kwargs)
        return cls._instances[cls]

class Singleton(metaclass=SingletonMeta):
    def some_business_logic(self):
        pass

# 测试
s1 = Singleton()
s2 = Singleton()

print(s1 is s2)  # 输出: True
```

# 装饰器模式

装饰器模式(Decorator Pattern)是一种结构型设计模式, 它允许用户在不修改已有对象结构的情况下, 动态地给对象添加额外的职责或功能。装饰器模式通过创建一系列装饰类来包裹原始类, 从而实现增强功能。这种模式通常用于遵循开放-关闭原则(Open/Closed Principle), 即软件实体应该对扩展开放, 对修改关闭。

### 主要组成部分

1. **组件(Component)** : 定义一个接口或抽象类, 可以为具体的组件和装饰器提供统一的接口
2. **具体组件(Concrete Component)** : 实现了组件接口的类, 表示被装饰的对象
3. **装饰器(Decorator)** : 持有一个组件对象的引用, 并且实现与组件相同的接口。装饰器可以在其具体组件的基础上添加额外功能
4. **具体装饰器(Concrete Decorator)** : 扩展了装饰器类, 增加了额外的行为或状态

```python
# 定义组件接口
class Text:
    def get_content(self):
        pass

# 具体组件
class SimpleText(Text):
    def __init__(self, content):
        self._content = content

    def get_content(self):
        return self._content

# 装饰器基类
class TextDecorator(Text):
    def __init__(self, text):
        self._text = text

    def get_content(self):
        return self._text.get_content()

# 具体装饰器: 加密文本
class EncryptedTextDecorator(TextDecorator):
    def get_content(self):
        original_content = super().get_content()
        # 这里简单模拟加密过程
        return f"Encrypted({original_content})"

# 具体装饰器: 文本格式化
class FormattedTextDecorator(TextDecorator):
    def get_content(self):
        original_content = super().get_content()
        # 这里简单模拟格式化过程
        return f"*** {original_content} ***"

# 使用示例
if __name__ == "__main__":
    simple_text = SimpleText("Hello, Decorator Pattern!")
    
    # 使用加密装饰器
    encrypted_text = EncryptedTextDecorator(simple_text)
    print(encrypted_text.get_content())  # Output: Encrypted(Hello, Decorator Pattern!)

    # 使用格式化装饰器
    formatted_text = FormattedTextDecorator(simple_text)
    print(formatted_text.get_content())  # Output: *** Hello, Decorator Pattern! ***

    # 使用多个装饰器
    combined_text = FormattedTextDecorator(encrypted_text)
    print(combined_text.get_content())  # Output: *** Encrypted(Hello, Decorator Pattern!) ***
```

### 优点

1. **增加灵活性**: 可以动态地添加或删除功能, 而不影响其他对象
2. **遵循开放-关闭原则**: 通过创建新的装饰器类来扩展功能, 而不需要修改现有代码
3. **可以组合使用多个装饰器**: 可以将多个装饰器组合在一起, 形成更复杂的功能

### 缺点

1. **增加复杂性**: 装饰器的使用会导致系统中类的数量增加, 可能会使系统变得更加复杂
2. **调试困难**: 由于使用了多个装饰器, 调试时可能不容易追踪问题所在

#### **语法糖形式**: 

```python
@decorator
def target_func():
    pass
```

等价于: 

```python
target_func = decorator(target_func)
```

#### **底层实现**: 

装饰器本质是一个接受函数作为参数的函数, 返回一个新函数: 

```python
def decorator(func):
    def wrapper(*args, **kwargs):
        # 前置逻辑
        result = func(*args, **kwargs)  # 调用原函数
        # 后置逻辑
        return result
    return wrapper
```

### **4. 关键应用场景**

- **日志记录**: 自动记录函数调用参数、耗时、结果。
- **权限校验**: 在函数执行前检查用户权限。
- **缓存(Memoization)** : 缓存函数结果, 避免重复计算。
- **性能分析**: 统计函数执行时间。
- **错误重试**: 在特定异常时自动重试函数。

### **5. 高级用法**

#### **带参数的装饰器**: 

通过嵌套函数传递参数: 

```python
def retry(max_attempts):
    def decorator(func):
        def wrapper(*args, **kwargs):
            for _ in range(max_attempts):
                try:
                    return func(*args, **kwargs)
                except Exception:
                    pass
            raise Exception("Retry failed")
        return wrapper
    return decorator

@retry(max_attempts=3)
def risky_operation():
    ...
```

#### **类装饰器**: 

通过实现 `__call__`​ 方法, 装饰器可以是一个类: 

```python
class Timer:
    def __init__(self, func):
        self.func = func

    def __call__(self, *args, **kwargs):
        start = time.time()
        result = self.func(*args, **kwargs)
        print(f"Time: {time.time() - start}s")
        return result

@Timer
def heavy_computation():
    ...
```

#### **装饰器链**: 

多个装饰器按从内到外的顺序执行: 

```python
@decorator1
@decorator2
def func():
    pass
```

等价于: 

```python
func = decorator1(decorator2(func))
```

### **6. 注意事项**

- **元信息丢失**: 装饰后的函数 `__name__`​ 等属性会被覆盖, 需用 `@functools.wraps(func)`​ 保留原信息。
- **执行时机**: 装饰器在函数定义时立即执行(而非调用时)。
- **调试复杂性**: 多层装饰器可能增加代码调试难度。



‍## 自省机制

- `dir()`: 用于类名或对象, 内置函数, 返回对象/类的属性和方法列表

- `isinstance(object, classinfo)`: 判断对象是否为某类的实例

- `type()`: 动态创建类

    - 传入一个参数则查看一个变量/对象的类型

    - 传入三个参数则创建一个类，type(name, bases, dict)，name为类名，bases为父类元组，dict为类属性/方法字典

        ```python
        MyClass = type('ClassA', (object,) dict(name="type test"))
        a = MyClass()
        
        # 等同于
        class ClassA:
        	name = "type test"
        
        a = ClassA()
        ```

- `hasattr(object/cls, '属性名')`: 检查对象/类是否有指定名称的属性/方法(包括继承的), 返回布尔值, 反射工具, 用于防御性编程

    - 属性名加引号, 若属性为字符串变量可省略引号
    - 若属性通过`__getattr__`​动态生成, 则`hasattr()`​可能返回False, 除非属性已被实际访问过

- `getattr(object/cls, '属性名', 默认值)`: 动态获取器, 设置默认值可避免报错, 可用于方法

    ```python
    class Dog:
        def bark(self):
            return "汪汪！"
    dog = Dog()
    bark_method = getattr(dog, "bark", None)
    if bark_method:
        print(bark_method())  # 输出: 汪汪！
    ```

- `setattr(object/cls, '属性名', value)`: 动态设置器, 动态地为对象添加或修改属性/方法, 若属性为描述符, 会触发描述符的`__set__`​方法

    ```python
    class Robot:
        pass
    robot = Robot()
    
    # 动态添加方法
    def attack(self):
        return f"{self.name} 发动攻击！"
    
    setattr(Robot, "attack", attack)  # 注意: 这里是给类添加方法
    print(robot.attack())  # 输出: Optimus 发动攻击！
    ```

##

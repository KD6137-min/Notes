# Python面向对象

将程序中的数据和行为封装在一起, 以对象的形式表示

> Python中一切皆对象

# 概述

- 类: 对象的模版, 元类的实例

  - 类属性: 直接定义在类中, 被所有对象所共有, 对象、类均可调用, 只能通过类修改

    - `__slot__`​槽: 特殊的类属性, 一种内存和属性管理机制, 内存优化工具, 用于限制类实例可动态添加的属性数量, 修改了类的内部结构(不涉及对象行为的约定, 不是协议)

      - 限制动态属性: 类实例只能拥有slot中指定的属性, 但仍可通过`__dict__`​强制添加(不推荐)

        ```python
        class MyClass:
            __slots__ = ['name', 'age']
        
        obj = MyClass()
        obj.y = 42 # 报错
        obj.__dict__['y'] = 42 # 不报错
        ```
      - 节省内存: Python对象默认有一个`__dict__`​属性用于存储动态添加的属性, `__slot__`​移除了`__dict__`​, 减少了内存开销, 也因此提高了属性的访问速度
      - 注意: `@property`​装饰器装饰的是方法, 因此不打破slot的限制, 实际可用@property装饰一个计算属性(使用已有属性计算得出)

  - 类方法: 不访问对象属性/方法, 只访问类属性的方法, 影响所有实例

    - `@classmethod`​装饰器修饰
    - 定义时第一个参数不是self, 而是<u>cls, 当前类</u>
    - 通过类名(常用, 节约内存)或对象名调用
    - `__new__`​是类方法, 参数为cls
    
  - 静态方法: 独立功能, 常用作辅助函数, 与类、对象无直接关系, 不访问对象属性/方法或类属性的方法
  
    - `@staticmethod`​装饰器修饰
    - 通过类名、对象可调用, 仅写在类中, 无self/cls形参
    - 不调用其他方法, 只能调用类的静态成员
    
  - 类之间的关系: 
  
    - is-a: 继承/泛化
    - has-a: 关联, 若为整体和部分的关联, 称为**聚合关系, ** 若整体和部分不可分割, 同时存在也同时消亡, 则为最强的关联关系, 称为**合成关系**
    - use-a: 称为**依赖关系**
  
- 对象: 类的实例

  - 属性: 随着对象创建而创建, 随着对象消失而消失, 多个对象之间相互独立, 互不干扰, 只能对象调用, 类不能调用

    - 实例属性与类属性分离: 给对象添加新属性不会直接影响类属性, 新属性存储在实例的`__dict__`​中, 其他同类实例不受影响
    - 私有属性: 只希望在对象内部被使用, 不希望外部使用, <u>并非强制, 只是提示调用者</u>, 且不影响子类的继承

      - > Python原则: 开放比封闭要好, 'We are all consenting adults here', 我们都是自愿的成年人, 我们应该自己对自己的行为负责而不是从语言层面来限制对数据或方法的访问
        >

      - 在属性/方法前加`__`​

        ```python
        def  __init__(self, name): 
        	# 私有属性
        	self.__age = 18 
        	self.name = name	# print(jerry.__age)会报错, 不能直接访问
        
        # 定义方法访问私有属性
        def secret(self): 
        	print(self.__age) 	# jerry.secret()可以输出18
        
        # 私有方法
        def __secret(self): 
        	print(self.__age) 	# jerry.__secret()会报错, 不能直接调用
        ```
      - 强制访问: `对象._类名__名称`​, 实际上是Python内部对私有属性、私有方法的name添加了前缀, 故无法直接访问

      - 设置访问:

        - 自定义函数方式:

          - 通过自定义getX函数访问私有属性: `get私有属性名`​(首字母大写)
          - 通过自定义setX函数设置私有属性: `set私有属性名`​(首字母大写)
        - 方法+`@property`​装饰器:

          - `@property`​, 属性getter, 只读
          - `@<property_name>.setter`​, 属性setter, 只写, 可添加验证或其他处理逻辑
          - `@<property_name>.deleter`​, 属性deleter
  - 方法: 第一个参数为self, 当前对象(显式传递self, 明确性, 可读性, 灵活性, 避免了隐式行为, 支持多继承)

    - 和函数的区别: 函数不属于任何类, 可直接调用
    - 特殊方法:

      - `__new__()`: 构造方法, 实例化对象, 是`类方法`​，需要返回一个实例，将该实例传递给`__init__`​的self参数
      - `__init__()`: 对象方法，初始化方法, 给对象添加属性并进行赋值, 一参必为self，其他参数与`__new__`​保持一致, 不允许有返回值
      - `__del__()`: 析构方法, 触发时机: 对象无引用(引用计数器为0, 若还有引用过, 则在所有代码执行结束的最后调用)、程序结束、对象被销毁
      - `__call__()`: 对象方法，定义一个对象作为函数调用时的行为, 即用()调用时, 触发该对象的`__call__()`​方法



# 属性查找机制

## **一、基本查找规则**

属性查找遵循以下优先级顺序(从低到高): 

1. **实例属性 (**​ **​`__dict__`​** ​ **)**

    - 检查实例自身的 `__dict__`​ 字典, 是否存在同名属性。
    - **优先级最低**, 但如果是通过 `self.attr`​ 访问, 实例属性会覆盖类属性。
2. **类属性 (**​ **​`__dict__`​** ​ **)**

    - 如果实例属性不存在, 则查找类对象的 `__dict__`​ 字典。
    - 包括显式定义的类属性、方法、以及通过 `@property`​ 等装饰器定义的属性。
3. **超类链 (**​ **​`__bases__`​** ​ **)**

    - 如果类属性也不存在, 按继承顺序向上遍历父类(通过 `__bases__`​), 直到找到属性或到达基类 `object`​。
    - 此过程类似于方法解析顺序(MRO)。
4. **元类 (**​ **​`__metaclass__`​** ​ **)**

    - 若类本身是通过元类定义的, 某些元类(如 `type`​)可能会参与属性查找。
    - 通常不直接涉及, 除非自定义元类重载了相关逻辑。

---

## **二、关键细节**

### 1. **描述符协议的影响**

当属性是描述符对象(实现了 `__get__`​/`__set__`​/`__delete__`​)时, 查找机制会被增强: 

- 描述符的 `__get__`​ 方法会被自动调用, 传入实例和类对象(`self`​, `instance`​, `klass`​)。

- 示例: 

    ```python
    class Descriptor:
        def __get__(self, instance, klass):
            return f"Descriptor value for {klass.__name__}"
    
    class MyClass:
        attr = Descriptor()
    
    obj = MyClass()
    print(obj.attr)  # 输出 "Descriptor value for MyClass"
    ```

### 2. **方法解析顺序 (MRO)**

在多重继承中, 属性查找遵循 MRO 顺序(如 `super()`​ 的行为)。例如: 

```python
class A:
    def foo(self): pass

class B(A):
    pass

class C(B):
    pass

# C 的 MRO 是 [C, B, A, object]
```

### 3.  **​`__getattr__`​** ​ **和**  **​`__setattr__`​** ​ **的覆盖**

- 如果实例定义了 `__getattr__`​ 方法, 当常规查找失败时会调用它。
- 类也可以定义 `__getattr__`​, 但需要通过元类或 `@classmethod`​ 实现。

示例: 

```python
class MyClass:
    def __getattr__(self, name):
        return f"Default value for {name}"

obj = MyClass()
print(obj.x)  # 输出 "Default value for x"
```

### 4.  **​`__slots__`​** ​ **的限制**

- 使用 `__slots__`​ 会限制实例只能访问预先声明的属性, 但仍可通过以下方式绕过: 

    1. 直接操作 `__dict__`​(不推荐)。
    2. 定义 `__getattr__`​ 方法处理未声明的属性。

示例: 

```python
class MyClass:
    __slots__ = ('x',)
    def __getattr__(self, name):
        return f"Slot protected: {name}"

obj = MyClass()
print(obj.x)       # 正常输出
print(obj.y)       # 输出 "Slot protected: y"
```

---

## **三、动态添加属性的注意事项**

1. **实例属性 vs 类属性**

    - 给实例添加属性(如 `obj.attr = 42`​)仅影响该实例。
    - 给类添加属性(如 `MyClass.attr = 42`​)会影响所有实例和子类。

2. **覆盖类属性**
    实例属性会"隐藏"同名的类属性, 但不会修改类属性本身: 

    ```python
    class MyClass:
        attr = 100
    
    obj = MyClass()
    print(obj.attr)  # 输出 100
    obj.attr = 200
    print(obj.attr)  # 输出 200
    print(MyClass.attr)  # 仍然输出 100
    ```

---

## **四、元类的深度干预**

元类可以完全重载属性查找逻辑, 例如通过 `__prepare__`​ 控制类字典的初始化: 

```python
class Meta(type):
    def __prepare__(cls, name, bases):
        return {"__slots__": ()}  # 强制使用 slots

class MyClass(metaclass=Meta):
    pass
```

---

## **五、查找流程图解**

```
实例属性 → 类属性 → 超类链 → 元类(特殊情况下)
```

---

## **六、示例演示**

```python
class A:
    class_attr = "I'm a class attribute"

    def instance_method(self):
        return "Instance method"

class B(A):
    def override_method(self):
        return "Overridden method"

obj = B()
# 查找步骤: 
1. obj.instance_method → 实例方法存在, 直接调用。
2. obj.class_attr → 实例无此属性, 查找类 B 的 __dict__ → 不存在, 沿超类链找到 A 的 class_attr。
3. obj.override_method → 实例方法存在, 直接调用。
4. obj.non_existent → 触发 __getattr__(若定义)或 AttributeError。
```

---

## **七、总结**

- **动态性**: Python 属性查找是动态的, 运行时可以动态添加或修改属性。
- **优先级**: 实例属性 > 类属性 > 超类链, 描述符协议和元类可改变默认行为。
- **设计原则**: 合理利用 `__slots__`​ 和描述符提升性能, 避免滥用 `__getattr__`​ 导致性能下降。

理解这一机制对掌握 Python 的面向对象编程、元类和装饰器等高级特性至关重要。



# 特殊方法

- `id()`: 查看对象的唯一标志(可视为内存地址)
- `dir()`: 用于类名或对象, 内置函数, 返回对象/类的属性和方法列表
- `isinstance(object, classinfo)`: 判断对象是否为某类的实例
- `type()`: 动态创建类

  - 传入一个参数则查看一个变量/对象的类型
  - 传入三个参数则创建一个类，type(name, bases, dict)，name为类名，bases为父类元组，dict为类属性/方法字典

    ```python
    MyClass = type('ClassA', (object,) dict(name="type test"))
    a = MyClass()
    
    # 等同于
    class ClassA:
    	name = "type test"
    
    a = ClassA()
    ```

- `hasattr(object/cls, '属性名')`: 检查对象/类是否有指定名称的属性/方法(包括继承的), 返回布尔值, 反射工具, 用于防御性编程

  - 属性名加引号, 若属性为字符串变量可省略引号
  - 若属性通过`__getattr__`​动态生成, 则`hasattr()`​可能返回False, 除非属性已被实际访问过
- `getattr(object/cls, '属性名', 默认值)`: 动态获取器, 设置默认值可避免报错, 可用于方法

  ```python
  class Dog:
      def bark(self):
          return "汪汪！"
  dog = Dog()
  bark_method = getattr(dog, "bark", None)
  if bark_method:
      print(bark_method())  # 输出: 汪汪！
  ```
- `setattr(object/cls, '属性名', value)`: 动态设置器, 动态地为对象添加或修改属性/方法, 若属性为描述符, 会触发描述符的`__set__`​方法

  ```python
  class Robot:
      pass
  robot = Robot()
  
  # 动态添加方法
  def attack(self):
      return f"{self.name} 发动攻击！"
  
  setattr(Robot, "attack", attack)  # 注意: 这里是给类添加方法
  print(robot.attack())  # 输出: Optimus 发动攻击！
  ```

# 元类

类的模版, 定义类的创建方式、行为和限制, 决定类本身的行为, 类定义中使用metaclass参数, 声明使用哪个元类

type是所有元类的父类, 用来定义和创建类，是一个元类，且为默认的元类

type是object的子类，object是type的一个实例，type的类型是type

![截屏2025-04-07 09.27.25](../assets/截屏2025-04-07%2009.27.25-20250407092728-rokq9io.png)

‍

![截屏2025-01-16 09.20.33](../assets/截屏2025-01-16%2009.20.33-20250116092037-hc8h29l.png)​​

```python
# 定义一个元类
class MyMeta(type):
    # 在类被创建之前, 可以修改类的属性
	def __new__(cls, name, bases, dct):
		dct['attr'] = 'Hello from Meta'
        return super().__new__(cls, name, bases, attrs)

# 通过元类(模具制造机)生成一个类(模具)
Dog = type('Dog', (object,), {'speak': lambda self: 'Woof!'})

# 生成一个对象(饼干)
dog = Dog()
print(dog.speak())  # 输出: 'Woof!'
```

## 定义元类的关键方法

- `__new__(cls, name, bases, dct)`: 创建类, 并控制类的结构, 核心方法

  - cls当前元类, name类名, bases父类元组, 包含所有正在创建类的父类, dct类的属性和方法字典
- `__init__(cls, name, bases, dict)`: 初始化类, new之后额外配置类属性或行为，元类的__init__主要用于类级别的验证/注入逻辑

  - cls：当前正被初始化的类，即元类的实例
  - name：类名
  - bases：类的父类元组
  - dict：类的属性和方法字典
- `__call__(cls, *args, **kwargs)`: 控制如何实例化类, `dog = Dog()`​就是触发了call方法
- `__prepare__(cls, name, bases)`: new之前准备类字典, 定制类定义过程

  ```python
  # 改变类属性的定义顺序
  from collections import OrderedDict
  
  class MyMeta(type):
  	def __prepare__(cls, name, bases):
  		return OrderedDict()
  
  	def __new__(cls, name, bases, dct):
  		print(dct)	# 输出OrderedDict()
  		return super().__new__(cls, name, bases, dct)
  ```

一个对象的创建过程：

![截屏2025-04-07 09.30.47](../assets/截屏2025-04-07%2009.30.47-20250407093049-6uvfs19.png)

## 单例模式

```python
class SingletonMeta(type):
    """
    元类, 用于实现单例模式
    """
	def __init__(cls, *args, **kwargs):
		cls.__instance = None		# 用于存储类的唯一实例
		cls.__lock = threading.RLock()
		super().__init__(*args, **kwargs)

    def __call__(cls, *args, **kwargs):
        """
        控制类的实例化逻辑
        """
        if cls.__instance is None:  # 如果实例不存在, 创建新实例并保存
			with cls.__lock():
				if cls.__instance is None:
					cls.__instance = super().__call__(*args, **kwargs)
        return cls.__instances


class SingletonClass(metaclass=SingletonMeta):
    """
    使用 SingletonMeta 作为元类的类
    """
    def __init__(self, value):
        self.value = value


# 测试单例模式
obj1 = SingletonClass(42)
obj2 = SingletonClass(99)

print(obj1 is obj2)  # 输出 True, 表示两个对象是同一个实例
print(obj1.value)   # 输出 42, 值与第一次实例化时相同
print(obj2.value)   # 输出 42
```

核心思想: 使用元类的`__call__`​方法, 控制类实例的创建, 如果已经存在实例(对象), 则返回现有的实例, 否则创建一个新实例

使用场景: 

- 资源共享: 例如数据库连接池、线程池
- 配置管理: 系统配置、全局配置管理器
- 日志管理: 确保日志对象在整个应用中唯一



# 元类钩子



**元类钩子**是指元类中可以重写的方法, 用于干预类的创建过程。通过这些钩子, 你可以自定义类的生成逻辑。

---

### **一、元类钩子是什么？**

元类钩子是元类中定义的特殊方法, 当使用元类创建类时, Python 会自动调用这些方法。常见的元类钩子包括: 

| 钩子方法                          | 作用                                | 调用时机              |
| --------------------------------- | ----------------------------------- | --------------------- |
| `__new__(mcs, name, bases, dct)`​  | 创建新类的实例(类对象)              | 最早被调用            |
| `__init__(cls, name, bases, dct)`​ | 初始化新创建的类对象                | 在 `__new__`​ 之后调用 |
| `__prepare__(mcs, name, bases)`​   | 自定义类字典的准备工作(Python 3.3+) | 在 `__new__`​ 之前调用 |

---

### **二、**​**​`type`​**​ **是元类吗？**

是的！`type`​ 是 Python 的内置元类, **所有类都是通过** **​`type`​**​ **创建的**。例如: 

```python
class MyClass:
    pass

# 等价于: 
MyClass = type('MyClass', (), {})  # 动态创建类
```

默认情况下, 类隐式继承自 `type`: 

```python
print(MyClass.__metaclass__)  # 输出: <class 'type'>
```

---

### **三、元类钩子的用途**

通过重写元类钩子, 可以实现以下功能: 

#### 1. **自定义类的属性**

```python
   class Meta(type):
       def __new__(mcs, name, bases, dct):
           dct['added_attr'] = 42  # 添加类属性
           return super().__new__(mcs, name, bases, dct)

   class MyClass(metaclass=Meta):
       pass

   print(MyClass.added_attr)  # 输出: 42
```

#### 2. **强制类型检查**

```python
   class IntegerMeta(type):
       def __init__(cls, name, bases, dct):
           for key, value in dct.items():
               if isinstance(value, int):
                   continue
               raise TypeError(f"All attributes must be integers!")

   class MyInts(metaclass=IntegerMeta):
       a = 10
       b = 20
       c = "30"  # 这会触发 TypeError
```

#### 3. **修改 MRO(方法解析顺序)**

```python
   class Meta(type):
       def __new__(mcs, name, bases, dct):
           # 将 bases 替换为一个新的元组, 插入自定义顺序
           return super().__new__(mcs, name, (mcs, bases[0]), dct)

   class A:
       pass

   class B(A, metaclass=Meta):
       pass

   print(B.__bases__)  # 输出: (<class '__main__.Meta'>, <class 'A'>)
```

---

### **四、**​**​`type`​**​ **的核心钩子**

#### 1. `__new__(mcs, name, bases, dct)`​

- **参数**: 

    - `mcs`: 元类自身(即 `type`​ 的实例)。
    - `name`: 类名(字符串)。
    - `bases`: 类的基类元组。
    - `dct`: 类的字典(包含类属性和方法)。
- **用途**: 创建并返回新的类对象。

#### 2. `__init__(cls, name, bases, dct)`​

- **参数**: 

    - `cls`: 新创建的类对象。
    - 其他参数同上。
- **用途**: 初始化类对象(例如设置类属性)。

#### 3. `__prepare__(mcs, name, bases)`​

- **参数**: 

    - `mcs`: 元类。
    - `name`​, `bases`: 同上。

- **用途**: 返回一个字典(默认为 `dict()`​ 或 `__slots__`​), 用于存储类的属性。

- **示例**: 

    ```python
    class Meta(type):
        def __prepare__(mcs, name, bases):
            return {"__slots__": ()}  # 强制使用 slots
    
    class MyClass(metaclass=Meta):
        x = 10
        y = 20
    # MyClass 的实例无法动态添加属性
    ```

---

### **五、实际应用场景**

1. **ORM 框架(如 Django)** 
    使用元类自动将类属性映射到数据库字段。
2. **单例模式**
    通过元类确保类只能被实例化一次。
3. **依赖注入**
    在类创建时自动注入依赖对象。

---

### **六、注意事项**

1. **Python 2 vs Python 3**

    - Python 2 中元类定义语法不同: `class MyClass(base_class): __metaclass__ = MyMeta`​。
    - Python 3 统一使用 `metaclass=MyMeta`​。
2. **避免过度使用元类**
    元类会显著增加代码复杂度, 优先考虑使用描述符、装饰器或类方法。
3. **调用链**

    - `type`​ 的 `__new__`​ → 自定义元类的 `__new__`​ → 自定义元类的 `__init__`​。

---

### **总结**

- **元类钩子**是元类中用于干预类创建的关键方法。
- **​`type`​**​ **是 Python 的默认元类**, 所有类均通过它生成。
- 合理使用元类钩子可以实现高级功能, 但需谨慎设计以避免复杂度过高。

‍



# 三大特性

封装性、继承性、多态性

## 继承性

`子类(父类)`​

- 父类/基类/根类&子类/派生类: 多类有相同属性方法, 抽取一类为父类, 子类继承
- 继承特性: 

  - 所有类都有父类, object类是所有类的父类, 无父类时默认父类为object
  - 子类直接继承父类的非私有属性、方法, 不可继承父类的私有属性、方法
  - 父类不能调用子类的方法
- 重写override: 

  - 父子属性不同: 重新初始化

    ```python
    def __init__(self, 公共属性, 新属性):
    	super().__init__(公共属性) 	# 继承公共属性
        self.新属性 = 新属性值
    ```
  - 父子方法不同: 在子类中定义方法, 只有子类可以调用, 若方法名相同, 子类覆盖父类方法
- 多继承: 继承多个父类`class 子类名(父类1,  父类2...):`​, 继承级别从左到右降低, 若父类有相同成员方法或成员变量, 优先继承左父类
- MRO: 方法解析顺序, 只读, 存储C3线性化计算的结果

  - `L[MyClass(Base1, Base2)] = MyClass + merge(L[Base1], L[Base2], Base1, Base2)`​, 即一个类的线性化为本类、父类的线性化、父类列表的合并的总和
  - `类名.mro()`​或`类名.__mro__`​查看
- `super()`​或`super(A, self)`: 查找和调用继承链中的下一个类的方法

  - `super(A, self)`​不是简单的直接访问父类, 而是通过MRO来查找下一个类

    - `A`: 以`A`​为基类, 查找**下一个父类**, 并且调用该父类的`__init__`​方法
    - `self`: 当前实例, `super()`​以此找到正确的上下文
  - 若父类的初始化方法中未使用`super()`​, 会断掉继承链的初始化, 只调用第一个父类的初始化方法, 建议在所有的地方都使用`super()`​

  ```python
  class A:
      def __init__(self):
          print("A's __init__ called")
          super().__init__() # ②调用A的__init__后, 该super仍基于C的MRO, 调用A之后的父类
  
  class B:
      def __init__(self):
          print("B's __init__ called")
          super().__init__() # ③调用后, 调用object的__init__(无操作)
  
  class C(A, B):
      def __init__(self):
          print("C's __init__ called")
          super().__init__() # ①根据C的MRO, 调用A的__init__
  ```
- 抽象类: 不能创建对象, 专门用于被继承, Python没有从语法层面支持抽象类

  - `继承ABC类`​和`@abstractmethod`​装饰器标记抽象方法, 两条件缺一不可

    - @abstractmethod用于标记抽象方法，表示子类必须实现此方法，但仅用`@abstractmethod`​无法定义抽象类, 类仍可实例化
    - 继承ABC使类成为抽象基类，在子类实例化时检查所有抽象方法是否实现
  - 多继承时必须显示调用super(), 确保元类冲突被正确处理
  - ABC和ABCMeta的区别：ABC继承自ABCMeta，内置支持注册虚拟子类，继承ABC即可定义抽象基类，无需显式指定metaclass=ABCMeta, 现代Python推荐继承ABC

  ```python
  from abc import ABCMeta, abstractmethod
  
  class Fighter(object, metaclass=ABCMeta):
  	@abstractmethod
  	def beat():
  		pass
  ```

## 多态性

不同子类调用同一父类方法时, 都调用对象私有方法(即用不同方式实现的父类方法)

支持鸭子类型测试: python不检查是否继承同一父类, 只要方法相同, 就是多态的



# 新式类

在 Python 中, "新式类"(new-style classes)是指继承了 `object`​ 类的类。新式类引入于 Python 2.2 版本, 并成为 Python 3 中的默认类类型。它们相较于旧式类(classic classes)具有更多的功能和特性, 特别是在面向对象编程方面。简单来说, 所有的类在 Python 3 中都默认是新式类。

### 新式类的特点: 

1. **继承自** **​`object`​**:

    - 新式类必须直接或间接地继承自 `object`​。如果你没有显式继承 `object`​, 在 Python 3 中类就会自动继承自 `object`​。
2. **支持** **​`super()`​** :

    - 新式类支持使用 `super()`​ 来调用父类的方法。`super()`​ 可以简化多重继承中的方法调用, 并且不会重复调用父类的方法。
3. **改进的**  **​`__mro__`​** ​  **(方法解析顺序)** :

    - 新式类使用一种更加明确和一致的方法解析顺序(MRO)。MRO 决定了在多重继承中, 方法是如何被查找和调用的。
4. **支持描述符协议**:

    - 新式类支持 Python 的描述符协议, 允许通过定义 `__get__`​、`__set__`​ 和 `__delete__`​ 方法来控制属性的访问。
5. **属性和方法的改进**:

    - 新式类对方法和属性的管理更加灵活和一致, 比如使用 `@property`​ 装饰器来创建属性。

### 是否需要显式继承 `object`​？

- 在 **Python 3** 中, 所有的类默认都是新式类, 不需要显式继承 `object`​。

    ```python
    class MyClass:
        pass
    ```

    以上代码中的 `MyClass`​ 已经是新式类, 因为 Python 3 中所有的类都自动继承自 `object`​。

- 在 **Python 2** 中, 只有显式继承 `object`​ 的类才是新式类, 否则默认是旧式类。为了使类成为新式类, 你需要显式地继承 `object`: 

    ```python
    class MyClass(object):  # 这是新式类
        pass
    
    class OldClass:  # 这是旧式类
        pass
    ```

    在 Python 2 中, 新式类和旧式类在某些行为上有所不同, 最显著的是新式类支持 `super()`​ 和多重继承中的方法解析顺序(MRO)。

### 总结

- 在 **Python 3** 中, 所有类默认都是新式类, 你不需要显式继承 `object`​。
- 在 **Python 2** 中, 为了使用新式类, 你需要显式地继承 `object`​。
- 新式类提供了许多强大的功能, 比如更好的继承支持、更一致的 MRO、多重继承的支持以及属性控制。

‍MRO

### 什么是 MRO(方法解析顺序)？

**MRO**(Method Resolution Order, 方法解析顺序)是 Python 中的一种机制, 用于确定在多重继承的情况下, 方法应该按什么顺序从父类中查找。简而言之, MRO 解决了当一个类继承多个类时, 如何查找方法的问题。

MRO 是多重继承中非常重要的概念, 它能够确保 Python 确定一个方法的查找顺序, 使得代码的行为更加可预测。

### MRO 的工作原理

当一个方法被调用时, Python 会从当前类开始, 逐步向上查找父类, 直到找到该方法为止。MRO 确定了这个查找的顺序。

MRO 的计算遵循以下几个规则: 

1. **深度优先遍历**: 从当前类开始向上查找, 查找的顺序通常是从左到右, 逐级向父类查找。
2. **遵循 C3 线性化规则(C3 Linearization)** : Python 使用 C3 线性化算法来计算 MRO, 确保有一个一致的查找顺序, 避免不确定性。

### MRO 的 C3 线性化规则

C3 线性化是 Python 采用的一个算法, 用于生成类的 MRO。它确保了在多重继承时, 类的继承关系是可预测的且没有冲突的。C3 线性化的规则保证了以下几点: 

- 子类的父类顺序不改变。
- 在多继承的情况下, 父类的顺序是根据类的继承结构自动计算出来的。
- 保证继承关系的"合理性", 即不允许父类间出现冲突。

### 示例: 计算 MRO

假设我们有以下类结构: 

```python
class A:
    def method(self):
        print("A method")

class B(A):
    def method(self):
        print("B method")

class C(A):
    def method(self):
        print("C method")

class D(B, C):
    pass
```

在这个例子中, `D`​ 类继承了 `B`​ 和 `C`​, `B`​ 和 `C`​ 都继承自 `A`​, 且都重写了 `method`​ 方法。我们想知道当 `D`​ 调用 `method()`​ 时, 方法会按什么顺序被查找。

```python
print(D.__mro__)  # 查看 MRO 顺序
```

### 输出: 

```
[<class '__main__.D'>, <class '__main__.B'>, <class '__main__.C'>, <class '__main__.A'>, <class 'object'>]
```

解释: 

- `D`​ 首先查找 `method()`​, 然后按照 MRO 顺序依次查找 `B`​, `C`​, `A`​, 最后 `object`​ 类(所有类的基类)。
- 由于 `D`​ 没有自己实现 `method()`​, 它会依次从 `B`​、`C`​ 和 `A`​ 中查找方法。

### C3 线性化如何确定 MRO？

C3 线性化的目的是根据类的继承顺序生成一个没有冲突的查找路径。对于类 `D`​, MRO 顺序的计算过程是: 

1. **D** 需要查找 `B`​ 和 `C`​ 中的 `method`​ 方法。
2. 在 `B`​ 和 `C`​ 中, 首先选择 `B`​, 因为 `B`​ 是 `D`​ 中声明的第一个父类。
3. 然后选择 `C`​, 因为 `C`​ 继承自 `A`​, 而 `A`​ 是 `B`​ 和 `C`​ 中的共同祖先。
4. 最后是 `A`​ 和 `object`​(Python 所有类的基类)。

### 通过 `super()`​ 使用 MRO

`super()`​ 函数在多重继承中会按照 MRO 顺序调用父类的方法。`super()`​ 默认调用下一个类的相应方法, 而这个下一个类由 MRO 确定。

继续上面的例子, 我们在 `D`​ 类中使用 `super()`​ 来调用父类的方法: 

```python
class D(B, C):
    def method(self):
        super().method()  # 使用 MRO 中下一个类的方法
```

如果我们创建 `D`​ 类的实例并调用 `method()`: 

```python
d = D()
d.method()
```

输出将会是: 

```
B method
```

这是因为 `super()`​ 会调用 `B`​ 类中的 `method()`​, `B`​ 是 `D`​ 类 MRO 中的下一个类。

### 如何查看 MRO？

可以通过 `.__mro__`​ 或 `mro()`​ 方法查看类的 MRO。

```python
print(D.__mro__)   # 或者
print(D.mro())
```

输出将是 MRO 顺序的列表, `D.__mro__`​ 返回的是类的 MRO 元组列表。

### MRO 例子: 复杂的多重继承

假设你有一个更加复杂的多重继承情况: 

```python
class A:
    def method(self):
        print("A method")

class B(A):
    def method(self):
        print("B method")

class C(A):
    def method(self):
        print("C method")

class D(B, C):
    pass

class E(C, B):
    pass

class F(D, E):
    pass
```

对于 `F`​ 类, 你可以查看它的 MRO 顺序: 

```python
print(F.__mro__)
```

输出会是: 

```
[<class '__main__.F'>, <class '__main__.D'>, <class '__main__.B'>, <class '__main__.C'>, <class '__main__.A'>, <class 'object'>]
```

### 总结

- **MRO** 是 Python 中多重继承机制的一部分, 用来确定方法查找的顺序。
- **C3 线性化** 是 Python 用于计算 MRO 的算法, 确保继承顺序的一致性和无冲突性。
- 你可以通过 `.__mro__`​ 或 `mro()`​ 查看类的 MRO 顺序。
- `super()`​ 会根据 MRO 顺序调用父类方法。

# C3线性化

### 什么是 C3 线性化？

**C3 线性化(C3 Linearization)**  是一种算法, 用于确定多重继承中方法解析顺序(MRO, Method Resolution Order)。它确保了在多继承的情况下, Python 确定方法调用的顺序是明确且一致的。C3 线性化算法通过对类的继承关系进行"线性化", 生成一种没有冲突的查找顺序, 从而避免了多继承中的一些复杂性和不确定性。

C3 线性化是 Python 在处理多重继承时的标准算法, 它确保了在类继承关系较复杂时, 方法解析能够按一定顺序执行。通过 C3 线性化, Python 确保了继承的顺序是 **一致的**, 避免了传统多继承中可能会出现的"钻石问题" **(Diamond Problem)** 。

### 钻石问题

在传统的多继承中, **钻石问题**指的是这样一种情况: 一个类继承了两个类, 这两个类又共同继承自同一个基类。这样会导致在查找父类方法时, 存在不明确的继承顺序。

#### 经典钻石问题示例

```python
class A:
    def method(self):
        print("A method")

class B(A):
    def method(self):
        print("B method")

class C(A):
    def method(self):
        print("C method")

class D(B, C):
    pass
```

在上面的代码中, `D`​ 类继承了 `B`​ 和 `C`​, 而 `B`​ 和 `C`​ 都继承自 `A`​。问题是, 当调用 `D`​ 类的 `method`​ 方法时, Python 应该从哪个父类(`B`​ 或 `C`​)查找该方法呢？

C3 线性化通过确定一个一致的查找顺序来解决这个问题, 避免了传统多继承中的歧义。

### C3 线性化的规则

C3 线性化算法遵循以下规则来确定 MRO(方法解析顺序): 

1. **深度优先**: 首先选择当前类中的父类, 如果某个父类已被选择过, 则不能再选择它。
2. **左到右顺序**: 从继承声明的顺序开始, 首先考虑类继承声明中从左到右的父类。
3. **保留父类顺序**: 当多个父类有相同的基类时, 父类的继承顺序应当保持一致。

### C3 线性化的计算过程

C3 线性化的基本思路是, 给定一组继承类的层次结构, 按照以下规则来计算每个类的 MRO: 

1. **选择最左边且没有父类冲突的父类**: 首先从当前类的父类中, 选择最左边且没有与其他父类发生冲突的类。
2. **排除已经选中的父类**: 选择一个父类后, 排除它和它的所有父类, 不再选择它们。
3. **重复上述步骤**: 直到所有父类都被选中, 得到最终的 MRO 顺序。

### C3 线性化示例

让我们通过以下例子来演示 C3 线性化的具体工作原理: 

#### 示例代码

```python
class A:
    def method(self):
        print("A method")

class B(A):
    def method(self):
        print("B method")

class C(A):
    def method(self):
        print("C method")

class D(B, C):
    pass
```

### MRO 的计算过程

我们要计算 `D`​ 类的 MRO。步骤如下: 

1. **选择 D 类**: 

    - `D`​ 作为当前类, 我们需要计算它的父类顺序。
2. **选择** **​`B`​**​ **和** **​`C`​**: 

    - `D`​ 继承了 `B`​ 和 `C`​, 现在我们需要选择这两个类中的一个。
    - 按照从左到右的顺序, 首先选择 `B`​。同时, `B`​ 没有和其他类(如 `C`​)发生冲突, 因此 `B`​ 先被选中。
3. **选择** **​`C`​**: 

    - `C`​ 和 `B`​ 之间没有冲突, `C`​ 被选中。
4. **选择** **​`A`​**: 

    - 最后, `A`​ 是 `B`​ 和 `C`​ 的共同父类, 应该被选择。

因此, 最终的 MRO 顺序是: `D -> B -> C -> A -> object`​。

### 验证 MRO

我们可以通过 `__mro__`​ 属性来验证 MRO: 

```python
print(D.__mro__)
```

输出结果为: 

```
[<class '__main__.D'>, <class '__main__.B'>, <class '__main__.C'>, <class '__main__.A'>, <class 'object'>]
```

这表示 `D`​ 类的 MRO 顺序是: `D -> B -> C -> A -> object`​, 符合 C3 线性化规则。

### Python 3 中的多重继承

在 Python 3 中, 所有的类默认都使用 C3 线性化算法计算 MRO, 因此在多重继承时, Python 会按照 C3 线性化规则来确保方法查找顺序的一致性和合理性。

### 总结

- **C3 线性化** 是一种算法, 用于确定多重继承中方法查找的顺序, 确保类的继承关系是清晰和一致的。
- 它通过深度优先、左到右的顺序以及避免父类冲突来生成一个不冲突的 MRO。
- **钻石问题**是 C3 线性化解决的一个典型问题, 它保证了类的继承顺序是可预测的, 避免了传统多继承中的不确定性。

‍type()

`Type('classname', (object,), {})`​ 是 Python 中的一个动态类型创建语法, 使用 `type()`​ 函数来创建一个新的类。

我们可以拆解这条语句来逐步理解: 

### 1. `type()`​

在 Python 中, `type()`​ 是一个内置函数。它有几种用法, 最常见的是: 

- `type(object)`: 返回对象的类型。
- `type(name, bases, dict)`: 创建一个新的类, 接受三个参数: 

    - `name`: 新类的名称, 通常是一个字符串。
    - `bases`: 新类的父类元组(可以是多个父类)。如果没有父类, 使用 `(object,)`​ 来继承 `object`​ 类。
    - `dict`: 一个字典, 包含类的属性和方法。

### 2. `'classname'`​

这是新类的名称, 指定了该类的名称为 `'classname'`​。

### 3. `(object,)`​

这是新类的父类元组, 指定新类继承自 `object`​ 类。由于 `object`​ 是所有类的基类, 因此这里 `(object,)`​ 表示新类是一个从 `object`​ 继承来的普通类。

### 4. `{}`​

这是一个空字典, 用来表示新类的属性和方法。在这个例子中, 字典为空, 意味着新类没有任何自定义的属性或方法。

### 总结: 

`Type('classname', (object,), {})`​ 的意思是: 

- 创建一个名为 `'classname'`​ 的新类。
- 该类没有任何自定义方法或属性。
- 该类继承自 `object`​ 类(即默认从 `object`​ 类继承)。

通过这种方式创建的新类是动态生成的, 可以在运行时使用, 并且具有标准类的功能。

#### 示例代码: 

```python
# 使用 type 创建一个新类
MyClass = type('MyClass', (object,), {})

# 创建 MyClass 类的实例
instance = MyClass()

# 查看实例类型
print(type(instance))  # <class '__main__.MyClass'>
```

上面的代码创建了一个名为 `MyClass`​ 的新类, 继承自 `object`​, 并且没有任何属性或方法。

# super()

`super()`​ 是 Python 中的一个内置函数, 用于调用父类的方法或属性。它的用法相对灵活, 主要有以下几种形式, 具体情况取决于你使用的 Python 版本和需求。

### Python 3 中的 `super()`​

在 Python 3 中, `super()`​ 可以不带任何参数, 自动使用当前类和当前实例。基本用法如下: 

```python
class Parent:
    def __init__(self):
        print("Parent init")

class Child(Parent):
    def __init__(self):
        super().__init__()  # 不需要参数
        print("Child init")

# 创建 Child 的实例
child_instance = Child()
```

#### 解释: 

- `super()`: 没有参数时, 自动推断出当前类和实例, 因此可以直接调用父类的方法。

### Python 2 中的 `super()`​

在 Python 2 中, 使用 `super()`​ 时需要传递两个参数: 当前类和当前实例。基本语法如下: 

```python
class Parent(object):  # 注意这里通常要继承 object, 使用新式类
    def __init__(self):
        print("Parent init")

class Child(Parent):
    def __init__(self):
        super(Child, self).__init__()  # 需要传递参数
        print("Child init")

# 创建 Child 的实例
child_instance = Child()
```

#### 参数解释: 

- `Child`: 第一个参数是类名, 指定你要调用其父类的方法的类。
- `self`: 第二个参数是当前实例, 指定你要使用的实例。

### 参数的作用

1. **类名**: 帮助 `super()`​ 确定要调用哪个父类的方法。如果你在多重继承的环境中, 类名对于确定调用链非常重要。
2. **实例**: 指定当前的实例, 以便在父类方法中可以引用当前对象的属性和方法。

### MRO(方法解析顺序)

在多重继承情况下, `super()`​ 会遵循方法解析顺序(MRO), 确保按照正确的顺序调用父类的方法。MRO 是 Python 在多重继承时决定方法查找顺序的一种机制。可以使用 `ClassName.__mro__`​ 或 `ClassName.mro()`​ 方法查看 MRO。

### 示例代码

以下是一个多重继承的示例, 展示了 `super()`​ 的使用和 MRO: 

```python
class A:
    def method(self):
        print("Method from A")

class B(A):
    def method(self):
        print("Method from B")
        super(B, self).method()  # 调用父类 A 的方法

class C(A):
    def method(self):
        print("Method from C")
        super(C, self).method()  # 调用父类 A 的方法

class D(B, C):
    def method(self):
        print("Method from D")
        super(D, self).method()  # 调用父类 B 的方法

# 创建 D 的实例
d_instance = D()
d_instance.method()

# 查看 MRO
print(D.mro())
```

#### 输出: 

```
Method from D
Method from B
Method from C
Method from A
```

#### MRO: 

```
[<class '__main__.D'>, <class '__main__.B'>, <class '__main__.C'>, <class '__main__.A'>, <class 'object'>]
```

### 总结

- 在 Python 3 中, `super()`​ 可以不带参数, 简化了调用父类方法的过程。
- 在 Python 2 中, 使用 `super(CurrentClass, self)`​ 方式需要明确指定类和实例。
- `super()`​ 支持多重继承, 遵循 MRO 确保方法调用的顺序正确。

‍

---

‍

# Mixin混入

一种编程范式, 主要用于**类的继承**(将额外功能注入目标类), 允许将多个功能模块化(只实现一个/一组功能), 并将它们'混入'到其他类(常与多继承一起使用)中, 从而实现**代码复用**和**功能扩展**, 不设计为独立的类实例, 不存储状态

```python
# 提供驾驶功能的Mixin类
class DrivableMixin:
    def drive(self):
        print(f'{self.__class__.__name__} is driving.')


# 提供加速功能的Mixin类
class AcceleratableMixin:
    def accelerate(self):
        print(f'{self.__class__.__name__} is accelerating.')


# 目标类, 将Drivable和Acceleratable的功能'混入'到自己身上
class Car(DrivableMixin, AcceleratableMixin):
    def __init__(self, brand):
        self.brand = brand

car = Car('Toyota')
car.drive()         # 输出: Car is driving.
car.accelerate()    # 输出: Car is accelerating.
```

注意:

- 避免状态管理: Mixin不应管理状态或依赖于实例变量, 其目的是提供方法, 而非持有数据
- 避免命名冲突: 多个Mixin可能会提供同名的方法或属性, 设计时需避免命名冲突

  - Python的方法解析顺序(MRO)决定多个类有相同方法时, 哪个方法优先执行
- 避免滥用多继承: Mixin可帮助分割, 但易让类的继承结构变复杂(尤其是多个Mixin嵌套)
- 保持接口一致性: 在不同类中混入多个Mixin时, 应确保其接口一致, 避免不同Mixin之间产生矛盾或依赖关系

```python
# 自定义字典限制只有在指定的key不存在时才能在字典中设置键值对
class SetOnceMappingMixin:
    """自定义混入类"""
    __slots__ = ()

    def __setitem__(self, key, value):
        if key in self:
            raise KeyError(str(key) + ' already set')
        return super().__setitem__(key, value)


class SetOnceDict(SetOnceMappingMixin, dict):
    """自定义字典"""
    pass


my_dict= SetOnceDict()
try:
    my_dict['username'] = 'jackfrued'
    my_dict['username'] = 'hellokitty'
except KeyError:
    pass
print(my_dict)
```

# 面向对象设计原则

- SOLID原则

  - 单一职责原则(SRP): 一个类只负责一个职责或一个功能, 这个原则强调的是**高内聚**、低耦合, 可以降低类的复杂度, 提高代码的可读性、可维护性和可重用性
  - 开闭原则(OCP): 一个类的行为应该是**可扩展**的, 但是**不可修改**, 这个原则强调的是代码的可维护性和可扩展性, 通过抽象化来避免修改已有代码的风险, 从而降低软件维护的成本
  - 里氏替换原则(LSP): 子类应该可以替换其父类并且不会影响程序的正确性, 这个原则强调的是面向对象的继承和多态特性, 通过保证子类的行为和父类一致, 从而提高代码的可维护性和可扩展性
  - 接口隔离原则(ISP): 一个类不应该依赖它不需要的接口, 即一个类对其它类的依赖应该建立在最小的接口上, 这个原则强调的是接口设计的合理性, 避免不必要的接口导致类之间的耦合性过高, 从而提高代码的灵活性和可维护性
  - 依赖倒置原则(DIP): **依赖于抽象**而不是依赖于具体实现, 这个原则强调的是代码的可扩展性和可维护性, 通过抽象化来减少组件之间的耦合性, 从而使得代码更加灵活、易于维护和扩展
  - SOLID原则的扩展: 

    - KISS原则: Keep It Simple, Stupid, 系统设计应该保持简单, 避免不必要的复杂性
    - YAGNI原则: You Aren't Gonna Need It, 不要为将来可能需要的功能过度设计或预先实现, 专注于当前需求, 避免浪费时间和资源

- 迪米特法则(LoD): 也叫最少知识原则(LKP), 一个对象应当对其他对象有尽可能少的了解, 不需要了解的内容尽量不要去了解, 这个原则强调的是组件之间的松耦合, 通过减少组件之间的依赖关系, 提高代码的可维护性和可重用性
- 组合/聚合复用原则(CARP): 尽量使用组合或聚合关系, 而不是继承关系来达到代码复用的目的, 这个原则强调的是通过组合和聚合的方式来实现代码复用, 避免继承带来的一些问题, 如父类和子类之间的强耦合性, 从而提高代码的灵活性和可维护性

# GoF设计模式

设计模式: 指一套被广泛接受的、可重复使用的软件设计解决方案

23种, 三类

## 创建型模式

涉及对象的创建机制, 并提供了一种**将对象的创建和使用分离**的方式

- 工厂模式: 定义一个创建对象的接口, 让子类决定实例化哪一个类, 工厂方法使一个类的实例化延迟到其子类
- 抽象工厂模式: 提供一个创建一系列相关或相互依赖对象的接口, 而无需指定它们的具体类
- 单例模式: 确保一个类只有一个实例, 并提供对该实例的全局访问点
- 建造者模式: 将一个复杂对象的构建与它的表示分离, 使得同样的构建过程可以创建不同的表示
- 原型模式: 通过复制现有的实例来创建新的对象, 而不是使用构造函数

## 结构型模式

涉及将类或对象组合在一起形成更大的结构, 并提供了一种简化设计的方式

- 适配器模式: 将一个类的接口转换成客户希望的另一个接口, 适配器模式可以让原本由于接口不兼容而不能在一起工作的类可以一起工作
- 桥接模式: 将抽象部分与它的实现部分分离, 使它们都可以独立地变化
- 组合模式: 将对象组合成树形结构以表示部分-整体的层次结构 组合模式使得用户对单个对象和组合对象的使用具有一致性
- 装饰器模式: 动态地将责任附加到对象上, 提供了一种灵活的替代继承的方式
- 外观模式/门面模式: 为子系统中的一组接口提供一个一致的界面, 使得子系统更容易使用
- 享元模式: 运用共享技术来有效地支持大量细粒度对象的复用
- 代理模式: 为其他对象提供一种代理以控制对这个对象的访问, 代理对象可以在被代理对象执行操作前后进行一些预处理和后处理

## 行为型模式

涉及对象之间的通信和算法的分配, 并提供了一种实现松散耦合的方式

- 责任链模式: 为解除请求的发送者和接收者之间耦合, 而使多个对象都有机会处理这个请求
- 命令模式: 将请求封装成一个对象, 从而使你可以用不同的请求对客户进行参数化, 命令模式也支持撤销操作
- 解释器模式: 是一种行为型设计模式, 它提供了一种方法, 可以在运行时解释语言文法中的表达式, 并执行相应的操作
- 迭代器模式: 提供一种方法顺序访问一个聚合对象中的各个元素, 而又不暴露该对象的内部表示
- 中介者模式: 用一个中介对象来封装一系列的对象交互, 中介者使各个对象不需要显式地相互作用, 从而使其耦合松散, 而且可以独立地改变它们之间的交互
- 备忘录模式: 在不破坏封装性的前提下, 捕获一个对象的内部状态, 并在该对象之外保存这个状态, 备忘录模式可以在需要时将对象恢复到先前的状态
- 观察者模式: 定义对象间的一种一对多的依赖关系, 使得每当一个对象状态发生改变时, 所有依赖它的对象都会得到通知并自动更新
- 状态模式: 允许对象在其内部状态发生改变时改变它的行为, 对象看起来似乎修改了它的类
- 策略模式: 定义一系列算法, 将每个算法都封装起来, 并使它们之间可以互换, 使得算法可以独立于使用它的客户而变化

  ```python
  # 可插拔的哈希算法
  class StreamHasher:
      """哈希摘要生成器"""
  
      def __init__(self, alg='md5', size=4096):
          self.size = size
          alg = alg.lower()
          self.hasher = getattr(__import__('hashlib'), alg.lower())()
  
      def __call__(self, stream):
          return self.to_digest(stream)
  
      def to_digest(self, stream):
          """生成十六进制形式的摘要"""
          for buf in iter(lambda: stream.read(self.size), b''):
              self.hasher.update(buf)
          return self.hasher.hexdigest()
  
  def main():
      """主函数"""
      hasher1 = StreamHasher()
      with open('Python-3.7.6.tgz', 'rb') as stream:
          print(hasher1.to_digest(stream))
      hasher2 = StreamHasher('sha1')
      with open('Python-3.7.6.tgz', 'rb') as stream:
          print(hasher2(stream))
          
  if __name__ == '__main__':
      main()

- 模板方法模式: 定义一个算法框架, 并将一些步骤延迟到子类中实现, 以便在不改变算法结构的情况下, 允许子类重定义算法的某些步骤
- 访问者模式: 是一种行为型设计模式, 它可以让你在不修改对象结构的前提下, 定义作用于这些对象元素的新操作



# 单例模式

单例模式(Singleton Pattern)是一种设计模式, 确保一个类只有一个实例, 并提供一个全局访问点。下面是几种在 Python 中实现单例模式的常见方法。

### 1. 使用模块

在 Python 中, 模块是单例的, 因为在程序运行时, 一个模块只会被加载一次。如果需要实现单例模式, 可以直接使用模块: 

```python
# singleton.py
class Singleton:
    def some_business_logic(self):
        pass

singleton_instance = Singleton()
```

在其他模块中你可以这样访问: 

```python
# another_module.py
from singleton import singleton_instance

singleton_instance.some_business_logic()
```

### 2. 使用类属性

通过类属性来存储单例实例: 

```python
class Singleton:
    _instance = None

    def __new__(cls, *args, **kwargs):
        if not cls._instance:
            cls._instance = super(Singleton, cls).__new__(cls)
        return cls._instance

# 测试
s1 = Singleton()
s2 = Singleton()

print(s1 is s2)  # 输出: True
```

### 3. 使用装饰器

可以使用装饰器来实现单例模式: 

```python
def singleton(cls):
    instances = {}

    def get_instance(*args, **kwargs):
        if cls not in instances:
            instances[cls] = cls(*args, **kwargs)
        return instances[cls]

    return get_instance

@singleton
class Singleton:
    def some_business_logic(self):
        pass

# 测试
s1 = Singleton()
s2 = Singleton()

print(s1 is s2)  # 输出: True
```

### 4. 使用元类

使用元类定义单例: 

```python
class SingletonMeta(type):
    _instances = {}

    def __call__(cls, *args, **kwargs):
        if cls not in cls._instances:
            cls._instances[cls] = super(SingletonMeta, cls).__call__(*args, **kwargs)
        return cls._instances[cls]

class Singleton(metaclass=SingletonMeta):
    def some_business_logic(self):
        pass

# 测试
s1 = Singleton()
s2 = Singleton()

print(s1 is s2)  # 输出: True
```

### 总结

以上是几种实现单例模式的方法。每种方法都有其优缺点, 可以根据具体的需求选择适合的实现方式。对于大多数简单的应用, 使用类属性或模块方法通常足够。而对于更复杂的需求, 可能需要考虑使用装饰器或元类。

# 装饰器模式

装饰器模式(Decorator Pattern)是一种结构型设计模式, 它允许用户在不修改已有对象结构的情况下, 动态地给对象添加额外的职责或功能。装饰器模式通过创建一系列装饰类来包裹原始类, 从而实现增强功能。这种模式通常用于遵循开放-关闭原则(Open/Closed Principle), 即软件实体应该对扩展开放, 对修改关闭。

### 主要组成部分

1. **组件(Component)** : 定义一个接口或抽象类, 可以为具体的组件和装饰器提供统一的接口。
2. **具体组件(Concrete Component)** : 实现了组件接口的类, 表示被装饰的对象。
3. **装饰器(Decorator)** : 持有一个组件对象的引用, 并且实现与组件相同的接口。装饰器可以在其具体组件的基础上添加额外功能。
4. **具体装饰器(Concrete Decorator)** : 扩展了装饰器类, 增加了额外的行为或状态。

### UML 类图

```
+-----------------+
|    Component    |
+-----------------+
| +operation()    |
+-----------------+
          ^
          |
+------------------------+
|   ConcreteComponent    |
+------------------------+
| +operation()           |
+------------------------+
          ^
          |
+------------------------+
|      Decorator        |
+------------------------+
| -component: Component  |
| +operation()          |
+------------------------+
          ^
          |
+------------------------+
|   ConcreteDecoratorA   |
+------------------------+
| +operation()           |
+------------------------+
          ^
          |
+------------------------+
|   ConcreteDecoratorB   |
+------------------------+
| +operation()           |
+------------------------+
```

### 示例: Python 中的装饰器模式

以下是一个用 Python 实现的装饰器模式的示例。假设我们有一个基础的文本处理类, 并希望在其基础上添加一些功能, 如文本加密和文本格式化。

```python
# 定义组件接口
class Text:
    def get_content(self):
        pass

# 具体组件
class SimpleText(Text):
    def __init__(self, content):
        self._content = content

    def get_content(self):
        return self._content

# 装饰器基类
class TextDecorator(Text):
    def __init__(self, text):
        self._text = text

    def get_content(self):
        return self._text.get_content()

# 具体装饰器: 加密文本
class EncryptedTextDecorator(TextDecorator):
    def get_content(self):
        original_content = super().get_content()
        # 这里简单模拟加密过程
        return f"Encrypted({original_content})"

# 具体装饰器: 文本格式化
class FormattedTextDecorator(TextDecorator):
    def get_content(self):
        original_content = super().get_content()
        # 这里简单模拟格式化过程
        return f"*** {original_content} ***"

# 使用示例
if __name__ == "__main__":
    simple_text = SimpleText("Hello, Decorator Pattern!")
    
    # 使用加密装饰器
    encrypted_text = EncryptedTextDecorator(simple_text)
    print(encrypted_text.get_content())  # Output: Encrypted(Hello, Decorator Pattern!)

    # 使用格式化装饰器
    formatted_text = FormattedTextDecorator(simple_text)
    print(formatted_text.get_content())  # Output: *** Hello, Decorator Pattern! ***

    # 使用多个装饰器
    combined_text = FormattedTextDecorator(encrypted_text)
    print(combined_text.get_content())  # Output: *** Encrypted(Hello, Decorator Pattern!) ***
```

### 优点

1. **增加灵活性**: 可以动态地添加或删除功能, 而不影响其他对象。
2. **遵循开放-关闭原则**: 通过创建新的装饰器类来扩展功能, 而不需要修改现有代码。
3. **可以组合使用多个装饰器**: 可以将多个装饰器组合在一起, 形成更复杂的功能。

### 缺点

1. **增加复杂性**: 装饰器的使用会导致系统中类的数量增加, 可能会使系统变得更加复杂。
2. **调试困难**: 由于使用了多个装饰器, 调试时可能不容易追踪问题所在。

### 适用场景

- 当需要给现有的类添加功能, 而不影响其他类时。
- 当功能需要以多个方式组合时, 例如在图形用户界面中, 按钮可能需要不同的样式和行为。
- 在需要遵循开放-关闭原则的情况下。

装饰器模式是一种非常灵活且强大的设计模式, 能有效扩展对象的功能, 同时保持良好的代码结构。

‍装饰器面试理解

---

### **1. 核心概念**

- **定义**: 
    装饰器是一种高阶函数(或类), 用于动态地修改或增强其他函数(或类)的行为, **不修改原函数/类的代码**。
- **本质**: 
    基于闭包(Closure)和函数式编程思想, 通过接受函数作为参数并返回新函数的方式实现功能扩展。

---

### **2. 核心作用**

- **代码复用**: 将通用逻辑(如日志、鉴权、缓存)从业务代码中解耦。
- **非侵入式扩展**: 在不修改原函数代码的情况下添加新功能。
- **组合性**: 通过多层装饰器叠加, 灵活组合多种功能。

---

### **3. 实现原理**

#### **语法糖形式**: 

```python
@decorator
def target_func():
    pass
```

等价于: 

```python
target_func = decorator(target_func)
```

#### **底层实现**: 

装饰器本质是一个接受函数作为参数的函数, 返回一个新函数: 

```python
def decorator(func):
    def wrapper(*args, **kwargs):
        # 前置逻辑
        result = func(*args, **kwargs)  # 调用原函数
        # 后置逻辑
        return result
    return wrapper
```

---

### **4. 关键应用场景**

- **日志记录**: 自动记录函数调用参数、耗时、结果。
- **权限校验**: 在函数执行前检查用户权限。
- **缓存(Memoization)** : 缓存函数结果, 避免重复计算。
- **性能分析**: 统计函数执行时间。
- **错误重试**: 在特定异常时自动重试函数。

---

### **5. 高级用法**

#### **带参数的装饰器**: 

通过嵌套函数传递参数: 

```python
def retry(max_attempts):
    def decorator(func):
        def wrapper(*args, **kwargs):
            for _ in range(max_attempts):
                try:
                    return func(*args, **kwargs)
                except Exception:
                    pass
            raise Exception("Retry failed")
        return wrapper
    return decorator

@retry(max_attempts=3)
def risky_operation():
    ...
```

#### **类装饰器**: 

通过实现 `__call__`​ 方法, 装饰器可以是一个类: 

```python
class Timer:
    def __init__(self, func):
        self.func = func

    def __call__(self, *args, **kwargs):
        start = time.time()
        result = self.func(*args, **kwargs)
        print(f"Time: {time.time() - start}s")
        return result

@Timer
def heavy_computation():
    ...
```

#### **装饰器链**: 

多个装饰器按从内到外的顺序执行: 

```python
@decorator1
@decorator2
def func():
    pass
```

等价于: 

```python
func = decorator1(decorator2(func))
```

---

### **6. 注意事项**

- **元信息丢失**: 装饰后的函数 `__name__`​ 等属性会被覆盖, 需用 `@functools.wraps(func)`​ 保留原信息。
- **执行时机**: 装饰器在函数定义时立即执行(而非调用时)。
- **调试复杂性**: 多层装饰器可能增加代码调试难度。

---

### **7. 面试加分点**

- **与设计模式的关系**: 装饰器模式是 GoF 23 种设计模式之一, Python 通过语法糖简化了其实现。
- **与继承的对比**: 装饰器更灵活, 适合横向扩展功能, 而继承是纵向的层次化扩展。
- **性能影响**: 装饰器可能引入额外函数调用开销, 需权衡使用场景。

---

### **示例回答**

"装饰器是 Python 中基于闭包的高阶函数, 用于在不修改原函数代码的前提下动态增强其功能。例如, 可以通过 `@log`​ 装饰器自动记录函数的调用信息, 或通过 `@cache`​ 实现结果缓存。装饰器的核心是接受一个函数作为参数, 返回一个新函数, 通过 `@`​ 语法糖简化调用。需要注意保留原函数的元信息, 并理解装饰器的执行时机。它在日志、鉴权等横切关注点的场景中非常高效, 符合开闭原则。"

---

通过这种结构化回答, 可以全面展示对装饰器的理解, 同时体现实际工程经验。

‍

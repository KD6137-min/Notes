# 面向对象

将程序中的数据和行为封装在一起, 以对象的形式表示，Python中一切皆对象

## 类

对象的模版, 元类的实例

**类之间的关系：**

- `is-a`：继承/泛化关系
- `has-a`：关联关系
    - 聚合关系：整体和部分，部分可以独立存在
    - 合成关系：最强的关联关系，整体和部分同时存在，同时消亡
- `use-a`：依赖关系

### 类属性

直接定义在类中, 被所有对象所共有, 对象、类均可调用, **只能通过类修改**

```python
class Student:
    school = '北科大'	# 类属性
    count = 0		  # 类属性
    
    def __init__(self, name):
        self.name = name	# 实例属性
        Student.count += 1	# 修改类属性
```

**`__slot__`槽**：特殊类属性，一种**内存和属性管理机制**, 内存优化工具, 用于限制类实例可动态添加的属性数量, 修改了类的内部结构(不涉及对象行为的约定, 不是协议)

- **限制动态属性:** 类实例只能拥有slot中指定的属性, 但仍可通过`__dict__`​强制添加(不推荐)

  ```python
  class MyClass:
      __slots__ = ['name', 'age']
  
  obj = MyClass()
  obj.y = 42 # 报错
  obj.__dict__['y'] = 42 # 强制添加，不推荐
  ```
- 节省内存: Python对象默认有一个`__dict__`​属性用于存储动态添加的属性, `__slot__`​移除了`__dict__`​, 减少了内存开销, 也因此提高了属性的访问速度
- 注意: `@property`​装饰器装饰的是方法, 因此不打破slot的限制, 实际可用@property装饰一个计算属性(使用已有属性计算得出)

### 类方法

不访问对象属性/方法, 只访问类属性的方法, 影响所有实例，用**`@classmethod`**​装饰器修饰，定义时第一个参数是**cls, 当前类**

```python
class Counter:
    count = 0
    
    @classmethod
    def increment(cls):
        cls.count += 1
        
    @classmethod
    def get_count(cls):
        return cls.count
    
# 调用方式
Counter.increment()	# 通过类名调用，推荐，节约内存
obj = Counter()
obj.increment()	# 可通过实例调用
```

### 静态方法

独立的功能函数，与类、对象无直接关系, 不访问对象属性/方法或类属性的方法，用**`@staticmethod`​**装饰器修饰，仅写在类中, 无self/cls形参，不调用其他方法, 只能调用类的静态成员

```python
class MathUtils:
    @staticmethod
    def add(a, b):
        return a + b
    
    @staticmethod
    def is_prime(n):
        if n < 2:
            return False
        for i in range(2, int(n ** 0.5) + 1):
            if n % i == 0:
                return False
        return True

# 调用方式
result = MathUtils.add(1, 2)  # 通过类名调用
obj = MathUtils()
result = obj.add(1, 2)        # 通过实例调用
```

### 新式类

继承了 `object`​ 类的类，比旧式类具有更多功能和特性

> - Python 2 中只有显式继承 `object` 的类才是新式类, 否则默认是旧式类
> - Python3 中默认为新式类

**特点:**

1. **继承自** **​`object`​**:新式类必须直接或间接地继承自 `object`​
2. **支持** **​`super()`​** :新式类支持使用 `super()`​ 来调用父类的方法
3. **改进的** **​`__mro__`​**:新式类使用一种更加明确和一致的方法解析顺序(MRO)
4. **支持描述符协议**: 允许通过定义 `__get__`​、`__set__`​ 和 `__delete__`​ 方法来控制属性的访问
5. **属性和方法的改进**:新式类对方法和属性的管理更加灵活和一致, 比如使用 `@property`​ 装饰器来创建属性

## 对象

类的实例

### 实例属性

随着对象创建而创建, 随着对象消失而消失, 多个对象之间相互独立, 互不干扰, 只能对象调用, 类不能调用

```python
class Person:
    def __init__(self, name, age):
        self.name = name      # 公有属性
        self.__age = age      # 私有属性
        self._height = 170    # 受保护属性（约定）
```

**实例属性与类属性分离:** 给对象添加新属性不会直接影响类属性, 新属性存储在实例的`__dict__`中, 其他同类实例不受影响，实例属性会"隐藏"同名的类属性, 但不会修改类属性本身

### 属性访问控制

- 传统**getter/setter**方式：

    ```python
    class Temperature:
        def __init__(self):
            self.__celsius = 0
            
        def get_celsius(self):
            return self.__celsius
        
        def set_celsius(self, value):
            if value < -273.15:
                raise ValueError('温度不能低于绝对零度')
            self.__celsius = value
    ```

- Property装饰器方式：`@property`修饰

    ```python
    class Temperature:
        def __init__(self):
            self.__celsius = 0
        
        @property
        def celsius(self):		# 属性getter，只读
            return self.__celsius
        
        @celsius.setter
        def celsius(self, value):	# 属性setter，可添加验证逻辑
            if value < -273.15:
                raise ValueError("温度不能低于绝对零度")
            self.__celsius = value
        
        @celsius.deleter	# 属性deleter
        def celsius(self):
            self.__celsius = 0
        
        @property
        def fahrenheit(self):	# 基于celsius的计算属性
            return self.__celsius * 9/5 + 32
    
    temp = Temperature()
    temp.celsius = 25
    print(temp.fahrenheit)  # 77.0
    ```

### 属性查找机制

#### `__getatttibute__()`

```python
obj.x	# 底层调用obj.__getattribute__('x')
```

所有属性访问都先经过`__getattribute__()`，其内部处理的**优先级顺序：**

1. **数据描述符**：若属性是**描述符对象**, 查找机制会被增强，描述符的 `__get__` 方法会被自动调用, 传入实例和类对象(`self`, `instance`, `klass`)

    ```python
    class Descriptor:
        def __get__(self, instance, klass):
            return f"Descriptor value for {klass.__name__}"
    
    class MyClass:
        attr = Descriptor()
    
    obj = MyClass()
    print(obj.attr)  # 输出 "Descriptor value for MyClass"
    ```

2. **实例属性**：检查实例自身的 **`__dict__`​ / `__slots__`**

3. **类属性**：若实例属性不存在, 则查找类对象的 **`__dict__`**​ 字典，包括显式定义的类属性、方法、以及通过 `@property`​ 等装饰器定义的属性

4. **超类链**：若类属性不存在, 按继承顺序(MRO)向上遍历父类(通过 **`__bases__`**​), 直到找到属性或到达基类 `object`​

> [!caution]
>
> `__getattribute__`很危险，如`return self.__dict__[x]`引发RecursionError无限递归，`__getattribute__`中任何属性访问都必须通过`super().__getattribute__()`：
>
> ```python
> def __getattribute__(self, name):
>     return super().__getattribute__(name)
> ```

#### `__getattr__()`

安全，常用，推荐，`__getattribute__()`失败抛出`AttributeError`，并调用**`__getattr__`**方法（异常兜底机制），若无，则真正报错，抛`AttributeError`查找失败

> 先`__getattribute__()`，失败了才`__getattr__()`

- 类也可以定义 `__getattr__`, 但需要通过元类或 `@classmethod` 实现

- 可添加虚拟属性：绕开slots限制，虽没地方存x属性，但可在`__getattr__`中计算/映射出一个x，如从别的字段派生/做懒加载，

    > 典型做法：`__slots__ = ('_data', ...)`，`__getattr__`查`_data`映射返回

- ≠ 内置函数`getattr`：

    ```python
    getattr(obj, 'x'[, default])	# 按属性查找机制执行一次属性访问，可提供default避免抛错
    ```
    
- 推荐提供默认属性：

    ```python
    class Config:
        def __getattr__(self, name):
            return None
        
    cfg = Config()
    cfg.timeout 	# None
    ```

### 实例方法

第一个参数为**self, 当前对象**(显式传递self, 明确性, 可读性, 灵活性, 避免了隐式行为, 支持多继承)

### 特殊方法

- `__new__()`: 元类`__call__`调用的类级构造钩子​，返回一个实例，将该实例传递给`__init__`​的self参数，是特殊实例方法，**类方法语义**（一参为cls）
- `__init__()`: 元类`__call__`调用，初始化方法, 给对象添加属性并进行赋值, 一参必为self，其他参数与`__new__`保持一致, 不允许有返回值
- `__str__()`：字符串表示，用户友好
- `__repr__()`：字符串表示，开发者友好
- `__del__()`：纯实例方法，由CPython/GC调用（在引用计数归零或清理循环引用时），**不是析构函数**，无法控制调用时机，甚至不能保证被调用，**避免使用**
- `__call__()`: 对象方法，定义一个对象作为函数调用时的行为, 即用()调用时, 触发该对象的`__call__()`​方法
- `__getattribute__()`：属性查找
- `__getattr__(cls, name)`：属性查找异常兜底

> [!important]
>
> 以上魔术方法放在普通类中就是实例级魔术方法，放在元类中就是类级魔术方法，具体级别要看具体**放在什么层级**

## 面向对象三大特性

### 封装性

**约定性**而非强制性，将数据和操作数据的方法结合在一起，隐藏对象的内部实现细节，提供访问控制

#### 约定

- `x`：普通公有
- `_x`：仅内部使用，允许调试/访问
- `__x`：伪私有属性，触发name mangling
- `__x__`：魔术方法

#### name mangling

对**伪私有属性**的一种**防命名冲突机制**，不是安全机制，`__attr`在类中被自动改成`_类名__attr`，本质是编译期重写名字字符串

触发规则：类作用域中，名字以`__`开头，不以`__`结尾

```python
class Person:
    def  __init__(self, name): 
        # 私有属性
        self.__age = 18 
        self.name = name

    # 定义方法访问私有属性
    def secret(self): 
        print(self.__age)

    # 私有方法
    def _secret(self): 
        print(self.__age)
        
jack = Person()
print(jack.__age)	# 报错
print(jack._secret())
print(jack._Person__age)	# 用._classname__attr 强制访问，不推荐
```

> [!note]
>
> **Python原则:** 开放比封闭要好, 'We are all consenting adults here', 我们应该自己对自己的行为负责而不是从语言层面来限制对数据或方法的访问

### 继承性

`子类(父类)`，允许新类获得现有类的属性和方法，实现代码复用

- object类是所有类的父类
- 子类直接继承父类的非私有属性、方法, 不可继承父类的私有属性、方法
- 多继承：继承多个父类`class 子类名(父类1,  父类2...):`​, 继承级别从左到右降低, 若父类有相同成员方法或成员变量, 优先继承左父类

```python
class Flyable:
    def fly(self):
        print("正在飞行")

class Swimmable:
    def swim(self):
        print("正在游泳")

class Duck(Animal, Flyable, Swimmable):
    def __init__(self, name):
        super().__init__(name)
    
    def speak(self):
        return f"{self.name} 嘎嘎叫"

duck = Duck("唐老鸭")
duck.fly()    # 来自Flyable
duck.swim()   # 来自Swimmable
duck.move()   # 来自Animal
```

#### MRO

Method Resolution Order，方法解析顺序，使用C3线性化算法，只读，当一个方法被调用时, Python 会从当前类开始, 逐步向上查找父类, 直到找到该方法为止

- `L[MyClass(Base1, Base2)] = MyClass + merge(L[Base1], L[Base2], Base1, Base2)`​, 即一个类的线性化为本类、父类的线性化、父类列表的合并的总和
- `类名.mro()`​或`类名.__mro__`​查看
- 在类创建时即按C3线性化确定好了

**MRO 计算规则:** 

1. **深度优先遍历**: 从当前类开始向上查找, 查找的顺序通常是从左到右, 逐级向父类查找
2. **遵循 C3 线性化规则** : C3 线性化规则保证子类的父类顺序不改变、保证多继承时父类的顺序是根据类的继承结构自动计算出来的、保证继承关系的"合理性"即不允许父类间出现冲突
    1. **选择最左边且没有父类冲突的父类**: 首先从当前类的父类中, 选择最左边且没有与其他父类发生冲突的类
    2. **排除已经选中的父类**: 选择一个父类后, 排除它和它的所有父类, 不再选择它们
    3. **重复上述步骤**: 直到所有父类都被选中, 得到最终的 MRO 顺序

#### `super()`

用于查找和调用**继承链**(MRO)中的下一个类，返回一个super对象（代理对象，知道当前类和当前实例）

- Python 3 中的 `super()`​可不带任何参数, 自动使用当前类和当前实例，Python 2 中的 `super(A, self)`​需要传递当前类和当前实例，以`A`​为锚点, 查找**下一个父类**，`self`为当前实例, `super()`​以此找到正确的上下文

- 若父类的初始化方法中未使用`super()`​, 会断掉继承链的初始化, 建议在所有的地方都使用`super()`​
- `super()`不会自动递归，只负责找下一站，到达终点后，执行init并**按调用栈顺序逐步回退**

```python
class A:
    def __init__(self):
        print("A before")
        super().__init__()
        print("A after")

class B(A):
    def __init__(self):
        print("B before")
        super().__init__()
        print("B after")

class C(A):
    def __init__(self):
        print("C before")
        super().__init__()
        print("C after")

class D(B, C):
    def __init__(self):
        print("D before")
        super().__init__()
        print("D after")

D()
"""
D before
B before
C before
A before
A after
C after
B after
D after
"""
```

#### 抽象类

不能创建对象, 专门用于被继承, Python没有从语法层面支持抽象类

- 实现：继承`ABC类`​和`@abstractmethod`​标记, 缺一不可

    - `@abstractmethod`：用于**标记**抽象方法，不会阻止实例化，内部只做了一件事：`A.__dict__['f'].__isabstractmethod__ == True`
    - 继承`ABC`：`ABCMeta`（`ABC`的父类）会扫描类和父类，收集所有`__isabstractmethod__ == True`的方法，生成一个集合`{'f', ...}`，在实例化A时检查该集合，非空则抛TypeError，阻止实例化

    > 声明与约束分离，抽象性靠语义约束而非语法

- `ABC`和`ABCMeta`的区别：`ABC`继承自`ABCMeta`，内置支持注册虚拟子类，继承ABC即可定义抽象基类，无需显式指定metaclass=ABCMeta, 现代Python推荐继承ABC

```python
from abc import ABCMeta, ABC, abstractmethod

# Python2 写法
class Fighter(object, metaclass=ABCMeta):
	@abstractmethod
	def beat():
		pass
    
# Python3 写法，推荐
class Fighter(ABC):
    @abstractmethod
    def beat():
        pass
```

#### Mixin混入

一种编程范式, 主要用于**类的继承**(将额外功能注入目标类), 允许将多个功能模块化(只实现一个/一组功能), 并将它们'混入'到其他类(常与多继承一起使用)中, 从而实现**代码复用**和**功能扩展**, 不设计为独立的类实例, 不存储状态

```python
# 提供驾驶功能的Mixin类
class DrivableMixin:
    def drive(self):
        print(f'{self.__class__.__name__} is driving.')


# 提供加速功能的Mixin类
class AcceleratableMixin:
    def accelerate(self):
        print(f'{self.__class__.__name__} is accelerating.')


# 目标类, 将Drivable和Acceleratable的功能'混入'到自己身上
class Car(DrivableMixin, AcceleratableMixin):
    def __init__(self, brand):
        self.brand = brand

car = Car('Toyota')
car.drive()         # 输出: Car is driving.
car.accelerate()    # 输出: Car is accelerating.
```

**注意:**

- 避免状态管理: Mixin不应管理状态或依赖于实例变量, 其目的是提供方法, 而非持有数据

- 避免命名冲突: 多个Mixin可能会提供同名的方法或属性, 设计时需避免命名冲突

    > Python的方法解析顺序(MRO)决定多个类有相同方法时, 哪个方法优先执行

- 避免滥用多继承: Mixin可帮助分割, 但易让类的继承结构变复杂(尤其是多个Mixin嵌套)

- 保持接口一致性: 在不同类中混入多个Mixin时, 应确保其接口一致, 避免不同Mixin之间产生矛盾或依赖关系

```python
# 自定义字典限制只有在指定的key不存在时才能在字典中设置键值对
class SetOnceMappingMixin:
    """自定义混入类"""
    __slots__ = ()

    def __setitem__(self, key, value):
        if key in self:
            raise KeyError(str(key) + ' already set')
        return super().__setitem__(key, value)


class SetOnceDict(SetOnceMappingMixin, dict):
    """自定义字典"""
    pass


my_dict= SetOnceDict()
try:
    my_dict['username'] = 'jackfrued'
    my_dict['username'] = 'hellokitty'
except KeyError:
    pass
print(my_dict)
```

### 多态性

不同子类调用同一父类方法时, 都调用对象私有方法(即用不同方式实现的父类方法)

支持鸭子类型测试: python不检查是否继承同一父类, 只要方法相同, 就是多态的

## 元类

类的模版, 定义类的创建方式、行为和限制, 决定类本身的行为

type是所有元类的父类, 用来定义和创建类，且为**默认的元类**

type是object的子类，object是type的一个实例，type是type的一个实例

> type比喻为词典，object是词，’词典’本身是词，’词’可以出现在词典里，’词典’也可以出现在词典里

![截屏2025-04-07 09.27.25](../assets/截屏2025-04-07%2009.27.25-20250407092728-rokq9io.png)

```python
# 继承type创建元类
class MyMeta(type):
    # 准备类字典，在__new__之前调用
    @classmethod
    def __prepare__(cls, name, bases, **kwargs):
        namespace = {}
        namespace['_creation_order'] = []
        return namespace
    
    # 在类被创建之前, 可以修改类的属性
	def __new__(cls, name, bases, dct):
		dct['attr'] = 'Hello from Meta'
        return super().__new__(cls, name, bases, dct)
```

> [!warning]
>
> - Python 2 中使用元类：`class MyClass(base_class): __metaclass__ = MyMeta`
> - Python 3 中使用元类：`class MyClass(metaclass=MyMeta):`

### 元类钩子

定义在元类中用于**拦截或改变**类对象本身行为的方法

一个对象的创建过程：

![截屏2025-04-07 09.30.47](../assets/截屏2025-04-07%2009.30.47-20250407093049-6uvfs19.png)

- `__new__(cls, name, bases, dct)`: 调用权在元类，逻辑定义权在类

  - cls当前元类, name类名, bases父类元组, 包含所有正在创建类的父类, dct类的属性和方法字典
  
- `__init__(cls, name, bases, dict)`: 初始化类, new之后额外配置类属性或行为，元类的__init__主要用于类级别的验证/注入逻辑

  - cls：当前正被初始化的类，即元类的实例
  - name：类名
  - bases：类的父类元组
  - dict：类的属性和方法字典
  
- `__call__(cls, *args, **kwargs)`: 控制如何实例化, `dog = Dog()`​就是触发了元类的`__call__`方法

- `__prepare__(cls, name, bases)`: new之前准备类字典, 定制类定义过程

  ```python
  # 改变类属性的定义顺序
  from collections import OrderedDict
  
  class MyMeta(type):
  	def __prepare__(cls, name, bases):
  		return OrderedDict()
  
  	def __new__(cls, name, bases, dct):
  		print(dct)	# 输出OrderedDict()
  		return super().__new__(cls, name, bases, dct)
  ```

## 面向对象设计原则与设计模式

### 设计原则

#### SOLID原则

- 单一职责原则(SRP): 一个类只负责一个职责或一个功能, 这个原则强调的是**高内聚**、低耦合, 可以降低类的复杂度, 提高代码的可读性、可维护性和可重用性
- 开闭原则(OCP): 一个类的行为应该是**可扩展**的, 但是**不可修改**, 这个原则强调的是代码的可维护性和可扩展性, 通过抽象化来避免修改已有代码的风险, 从而降低软件维护的成本
- 里氏替换原则(LSP): 子类应该可以替换其父类并且不会影响程序的正确性, 这个原则强调的是面向对象的继承和多态特性, 通过保证子类的行为和父类一致, 从而提高代码的可维护性和可扩展性
- 接口隔离原则(ISP): 一个类不应该依赖它不需要的接口, 即一个类对其它类的依赖应该建立在最小的接口上, 这个原则强调的是接口设计的合理性, 避免不必要的接口导致类之间的耦合性过高, 从而提高代码的灵活性和可维护性
- 依赖倒置原则(DIP): **依赖于抽象**而不是依赖于具体实现, 这个原则强调的是代码的可扩展性和可维护性, 通过抽象化来减少组件之间的耦合性, 从而使得代码更加灵活、易于维护和扩展

SOLID原则的**扩展:** 

- KISS原则: Keep It Simple, Stupid, 系统设计应该保持简单, 避免不必要的复杂性
- YAGNI原则: You Aren't Gonna Need It, 不要为将来可能需要的功能过度设计或预先实现, 专注于当前需求, 避免浪费时间和资源

#### 迪米特法则(LoD)

又称最少知识原则(LKP), 一个对象应当对其他对象有尽可能少的了解, 不需要了解的内容尽量不要去了解, 这个原则强调的是组件之间的松耦合, 通过减少组件之间的依赖关系, 提高代码的可维护性和可重用性

#### 组合/聚合复用原则(CARP)

尽量使用组合或聚合关系, 而不是继承关系来达到代码复用的目的, 这个原则强调的是通过组合和聚合的方式来实现代码复用, 避免继承带来的一些问题, 如父类和子类之间的强耦合性, 从而提高代码的灵活性和可维护性

### GoF设计模式

设计模式: 指一套被广泛接受的、可重复使用的软件设计解决方案

23种, 三类

#### 创建型模式

涉及对象的创建机制, 并提供了一种**将对象的创建和使用分离**的方式

- 工厂模式: 定义一个创建对象的接口, 让子类决定实例化哪一个类, 工厂方法使一个类的实例化延迟到其子类

- 抽象工厂模式: 提供一个创建一系列相关或相互依赖对象的接口, 而无需指定它们的具体类

- 建造者模式: 将一个复杂对象的构建与它的表示分离, 使得同样的构建过程可以创建不同的表示

- 原型模式: 通过复制现有的实例来创建新的对象, 而不是使用构造函数

- 单例模式: Singleton Pattern，确保一个类只有一个实例, 并提供对该实例的全局访问点，常见实现方法：

    - 使用模块：python程序运行时, 一个模块只会被加载一次

        ```python
        # singleton.py
        class Singleton:
            def some_logic(self):
                pass
        
        singleton_instance = Singleton()
        
        # another_module.py，在其他模块中：
        from singleton import singleton_instance
        
        singleton_instance.some_business_logic()
        ```

    - 使用类属性：

        ```python
        class Singleton:
            _instance = None
        
            def __new__(cls, *args, **kwargs):
                if not cls._instance:
                    cls._instance = super(Singleton, cls).__new__(cls)
                return cls._instance
        
        # 测试
        s1 = Singleton()
        s2 = Singleton()
        
        print(s1 is s2)  # 输出: True
        ```

    - 使用装饰器：

        ```python
        def singleton(cls):
            instances = {}
        
            def get_instance(*args, **kwargs):
                if cls not in instances:
                    instances[cls] = cls(*args, **kwargs)
                return instances[cls]
        
            return get_instance
        
        @singleton
        class Singleton:
            def some_business_logic(self):
                pass
        
        # 测试
        s1 = Singleton()
        s2 = Singleton()
        
        print(s1 is s2)  # 输出: True
        ```

    - 使用元类：元类维护一全局字典，支持多个不同单例类，不污染每个类的命名空间，使用元类的`__call__`方法, 控制类实例的创建逻辑

        ```python
        class SingletonMeta(type):
            _instances = {}
            _lock = threading.RLock()	# 线程安全
        
            def __call__(cls, *args, **kwargs):
                if cls not in cls._instances:
                    with cls._lock:
                        if cls not in cls._instances:
        		            cls._instances[cls] = super().__call__(*args, **kwargs)
                return cls._instances[cls]
        
        class Singleton(metaclass=SingletonMeta):
            def some_business_logic(self):
                pass
        
        # 测试
        s1 = Singleton()
        s2 = Singleton()
        
        print(s1 is s2)  # 输出: True
        ```


#### 结构型模式

涉及将类或对象组合在一起形成更大的结构, 并提供了一种简化设计的方式

- 适配器模式: 将一个类的接口转换成客户希望的另一个接口, 适配器模式可以让原本由于接口不兼容而不能在一起工作的类可以一起工作

- 桥接模式: 将抽象部分与它的实现部分分离, 使它们都可以独立地变化

- 组合模式: 将对象组合成树形结构以表示部分-整体的层次结构 组合模式使得用户对单个对象和组合对象的使用具有一致性

- 外观模式/门面模式: 为子系统中的一组接口提供一个一致的界面, 使得子系统更容易使用

- 享元模式: 运用共享技术来有效地支持大量细粒度对象的复用

- 代理模式: 为其他对象提供一种代理以控制对这个对象的访问, 代理对象可以在被代理对象执行操作前后进行一些预处理和后处理

- 装饰器模式: 一种灵活的替代继承的方式，允许用户在不修改已有对象结构的情况下, 动态地给对象添加额外的职责或功能，遵循开闭原则，可组合多个装饰器形成更复杂的功能

    - 主要组成部分：

        - **组件(Component)** : 定义一个接口或抽象类, 可以为具体的组件和装饰器提供统一的接口
        - **具体组件(Concrete Component)** : 实现了组件接口的类, 表示被装饰的对象
        - **装饰器(Decorator)** : 持有一个组件对象的引用, 并且实现与组件相同的接口。装饰器可以在其具体组件的基础上添加额外功能
        - **具体装饰器(Concrete Decorator)** : 扩展了装饰器类, 增加了额外的行为或状态

        ```python
        # 定义组件接口
        class Text:
            def get_content(self):
                pass
        
        # 具体组件
        class SimpleText(Text):
            def __init__(self, content):
                self._content = content
        
            def get_content(self):
                return self._content
        
        # 装饰器基类
        class TextDecorator(Text):
            def __init__(self, text):
                self._text = text
        
            def get_content(self):
                return self._text.get_content()
        
        # 具体装饰器: 加密文本
        class EncryptedTextDecorator(TextDecorator):
            def get_content(self):
                original_content = super().get_content()
                # 这里简单模拟加密过程
                return f"Encrypted({original_content})"
        
        # 具体装饰器: 文本格式化
        class FormattedTextDecorator(TextDecorator):
            def get_content(self):
                original_content = super().get_content()
                # 这里简单模拟格式化过程
                return f"*** {original_content} ***"
        
        # 使用示例
        if __name__ == "__main__":
            simple_text = SimpleText("Hello, Decorator Pattern!")
            
            # 使用加密装饰器
            encrypted_text = EncryptedTextDecorator(simple_text)
            print(encrypted_text.get_content())  
            # Output: Encrypted(Hello, Decorator Pattern!)
        
            # 使用格式化装饰器
            formatted_text = FormattedTextDecorator(simple_text)
            print(formatted_text.get_content())  
            # Output: *** Hello, Decorator Pattern! ***
        
            # 使用多个装饰器
            combined_text = FormattedTextDecorator(encrypted_text)
            print(combined_text.get_content())  
            # Output: *** Encrypted(Hello, Decorator Pattern!) ***
        ```

    - 语法糖形式：使用了装饰设计思想的语法机制，但不等于装饰器模式本身

        ```python
        @decorator
        def target_func():
            pass
        
        # 等价于
        target_func = decorator(target_func)
        ```

#### 行为型模式

涉及对象之间的通信和算法的分配, 并提供了一种实现松散耦合的方式

- 责任链模式: 为解除请求的发送者和接收者之间耦合, 而使多个对象都有机会处理这个请求
- 命令模式: 将请求封装成一个对象, 从而使你可以用不同的请求对客户进行参数化, 命令模式也支持撤销操作
- 解释器模式: 是一种行为型设计模式, 它提供了一种方法, 可以在运行时解释语言文法中的表达式, 并执行相应的操作
- 迭代器模式: 提供一种方法顺序访问一个聚合对象中的各个元素, 而又不暴露该对象的内部表示
- 中介者模式: 用一个中介对象来封装一系列的对象交互, 中介者使各个对象不需要显式地相互作用, 从而使其耦合松散, 而且可以独立地改变它们之间的交互
- 备忘录模式: 在不破坏封装性的前提下, 捕获一个对象的内部状态, 并在该对象之外保存这个状态, 备忘录模式可以在需要时将对象恢复到先前的状态
- 观察者模式: 定义对象间的一种一对多的依赖关系, 使得每当一个对象状态发生改变时, 所有依赖它的对象都会得到通知并自动更新
- 状态模式: 允许对象在其内部状态发生改变时改变它的行为, 对象看起来似乎修改了它的类
- 策略模式: 定义一系列算法, 将每个算法都封装起来, 并使它们之间可以互换, 使得算法可以独立于使用它的客户而变化

  ```python
  # 可插拔的哈希算法
  class StreamHasher:
      """哈希摘要生成器"""
  
      def __init__(self, alg='md5', size=4096):
          self.size = size
          alg = alg.lower()
          self.hasher = getattr(__import__('hashlib'), alg.lower())()
  
      def __call__(self, stream):
          return self.to_digest(stream)
  
      def to_digest(self, stream):
          """生成十六进制形式的摘要"""
          for buf in iter(lambda: stream.read(self.size), b''):
              self.hasher.update(buf)
          return self.hasher.hexdigest()
  
  def main():
      """主函数"""
      hasher1 = StreamHasher()
      with open('Python-3.7.6.tgz', 'rb') as stream:
          print(hasher1.to_digest(stream))
      hasher2 = StreamHasher('sha1')
      with open('Python-3.7.6.tgz', 'rb') as stream:
          print(hasher2(stream))
          
  if __name__ == '__main__':
      main()

- 模板方法模式: 定义一个算法框架, 并将一些步骤延迟到子类中实现, 以便在不改变算法结构的情况下, 允许子类重定义算法的某些步骤
- 访问者模式: 是一种行为型设计模式, 它可以让你在不修改对象结构的前提下, 定义作用于这些对象元素的新操作

## 自省 & 反射

### 自省

在运行时**观察**程序自身结构

- `dir()`: 用于类名或对象, 内置函数, 返回对象/类的属性和方法列表

- `isinstance(object, classinfo)`: 判断对象是否为某类的实例

- `issubclass(C, B)`：判断类C 是否是类B 的子类（或同一个类），底层是`B in C.__mro__`，二参可为元组，判断是否是任意一个类的子类

    > issubclass(A, A) 返回 True！

- `type()`: 

    - 传入一个参数则查看一个变量/对象的类型

    - 传入三个参数则动态创建一个类，`type(name, bases, dict)`，name为类名，bases为父类元组，dict为类属性/方法字典

        ```python
        MyClass = type('ClassA', (object,) dict(name="type test"))
        
        # 等同于
        class ClassA:
        	name = "type test"
        ```

### 反射

在运行时**检查并修改**程序结构和行为

- `hasattr(object/cls, '属性名')`: 检查对象/类是否有指定名称的属性/方法(包括继承的), 返回布尔值, 反射工具, 用于防御性编程

    - 属性名加引号, 若属性为字符串变量可省略引号
    - 若属性通过`__getattr__`​动态生成, 则`hasattr()`​可能返回False, 除非属性已被实际访问过

- `getattr(object/cls, '属性名', 默认值)`: 动态获取器, 设置默认值可避免报错, 可用于方法

    ```python
    class Dog:
        def bark(self):
            return "汪汪！"
    dog = Dog()
    bark_method = getattr(dog, "bark", None)
    if bark_method:
        print(bark_method())  # 输出: 汪汪！
    ```

- `setattr(object/cls, '属性名', value)`: 动态设置器, 动态地为对象添加或修改属性/方法, 若属性为描述符, 会触发描述符的`__set__`​方法

    ```python
    class Robot:
        pass
    robot = Robot()
    
    # 动态添加方法
    def attack(self):
        return f"{self.name} 发动攻击！"
    
    setattr(Robot, "attack", attack)  # 注意: 这里是给类添加方法
    print(robot.attack())  # 输出: Optimus 发动攻击！
    ```

**示例：**

```python
class Robot:
    def __init__(self, name):
        self.name = name
    
    def walk(self):
        return f"{self.name} 正在行走"

robot = Robot("Optimus")

# 动态方法调用
method_name = "walk"
if hasattr(robot, method_name):
    method = getattr(robot, method_name)
    print(method())  # "Optimus 正在行走"

# 动态添加方法
def attack(self):
    return f"{self.name} 发动攻击！"

setattr(Robot, "attack", attack)
print(robot.attack())  # "Optimus 发动攻击！"
```


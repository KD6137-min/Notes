![image](../assets/截屏2025-01-14%2015.08.32-20250114150848-dk60f7u.png)

# 一、Token

## 注释符

- 单行: `# `, 后接一个空格，快捷键(注释/取消注释)`command+/`

- 多行: 首尾两行三单/双引号顶格

    ```python
    ‘’‘
    This function is ...
    ’‘’
    ```

## 标识符

- 定义规则：

  - 数字、字母、下划线组成, 不能由数字开头(此处的字母包含所有国家的语言)
  - 严格区分大小写
  - 不能使用python的保留字、关键字(`print(keyword.kwlist)`​查看关键字)

- 命名规则

  - 下划线命名法, 变量、模块、函数常用
  - 大驼峰命名法, 类名常用
  - 小驼峰命名法
- 删除: `del 变量`​

## 标点符

- 英文文本
- 逗号, 后面加空格
- def、if等后面加冒号:
- 分号;  为语句结束的标记, Python一条语句独占一行, 不建议加分号, 若一行中有多条语句, 语句后必须加分号: 

  ```python
  print(9); print(10)
  ```
- 缩进符, 包含关系, 推荐使用4个空格而不是制表键, 或设置IDE自动将制表键变为4个空格(不同编辑器和环境对制表键的处理可能不同)
- 平级关系, 上下对齐
- 引号: 单引号和双引号用来定义字符串, 功能相同, 引号嵌套时可**交替使用避免混乱**

  三重引号: `'''`​、`"""`​可定义多行字符串

  ```python
  text = '''This is a
  multi-line string.'''
  ```

## 运算符

- 算术运算符:

  - 不同数据类型不能直接数学运算
  - 分类:

    - 一元运算符: 正负号, 正号省略
    - 二元运算符:

      - `+`: 加法, 字符串的加法为拼接, 二合一

      - `-`: 减法  
      - `*`: 乘法  
      - `/`: 除法, 结果为`float`​类型, 注意做类型转换

      - `%`: 取余  
      - `//`: (向下)取整
      
      - `**`: 幂, 前底后指, 指数可为正数(结果为int)、 负数、分数(结果为float)
  - 优先级:  `**`​ \> `正负号`​ \> `*、/、//、%`​ \> `加减`​, 用括号控制先后
  
- 赋值运算符: 

  - 简单赋值运算符`=`：前后均有空格，若变量名相同, 后覆盖前

    - 推荐使用临时变量交换: `a, b = b, a`
    
        - 底层会将其转换为**原子操作**，本质为元组打包和解包，实际执行：
    
            ```python
            _temp = (b, a)
            a, b = _temp
            ```
    
    - 可一次性赋值多个变量 (相同或一一对应)
    
      ```python
      x = y = z = 12
      a = b = c = 87, 43, 29
      ```
    
  - 复合赋值运算符：`+\=`、`-\=`、`\*\=`、`/\=`、`%\=`、`**=`，变量必须有初始值, 先运行\=右边的表达式, 再赋值(赋值的优先级最低)

  - 海象运算符`:=`​, 定义一个变量的同时参与另一变量的定义

    ```python
    y = 2 * ( x:= 7) +1
    ```

- 关系运算符：返回布尔值

  - 参与比较的数据需要能进行隐式转换 如: 字符串和整形不可比
  - `>`​、`<`​、`>=`​、`<=`​、`==`​、`!=`​(不等于)

    - `==`​检查两对象的`值`​是否相等，自动处理类型差异, 如`1==1.0`​返回`True`​
  - 支持链式比较, 即 `0 < n < 20`​
  - 字符串比较: 用ASCII码逐一比较, 第一个比不出来则比较第二个, 直到有结果
  
  - 常见ACSII码大小规则: 数字 < 大写字母 < 小写字母，数字0-9递增, 字母a-z递增, 常见: `A`​为65, `a`​为97, `0`​为48
  - 列表比较: 逐一比较元素大小, 与字符串方法雷同

- 逻辑运算符：

  - `not`非: 取反, True返回False, False返回True
  - `and`且: 全真返回True, 有一假则返回False
  - `or`或: 有一真则返回True, 全假则返回False
  - 短路原则: 结果可确定则忽略后面, 真或假与, 可替代if嵌套

    - `true`​ or `……`​, 直接输出true, 后面短路
    - `false`​ and `……`​, 直接输出 false, 后面短路
    - 短路求值: `a and b or c`​, **a真则返回b，a假则返回c**
  - 优先级: `not`​ > `and`​ > `or`​
  
- 成员运算符：`in`、`not in`，用于字符串、元组、列表的判断

  - Num不是容器类型, 不能使用成员运算符
  
- 位运算符：以二进位为单位进行运算, 操作数和结果均为整型

  |位运算符|名称|例子|
  | --------| --------| ---------|
  |`~`|位反|`~x`|
  |`&`|位与|`x&y`|
  |`|`|位或|`x|y`|
  |`^`|位异或|`x^y`|
  |`>>`|右移|`x >> a`|
  |`<<`|左移|`x << a`|
  
  - 取反:  `~a = -1*(a+1)`
  - 位与: 两位均为1, 结果才为1, 否则为0
  - 位或: 两位中只要有一个1, 结果为1, 否则为0
  - 位异或: `同1异0`，对任一数位异或两次结果为本身
  - 右移: 高位用符号位补位
  - 左移: 低位用0补位
  
- `is`身份运算符: `a is/is not b`, 判断两个数据的地址在内存中是否一致

- 三元运算符: `max = a if a > b else b`​

  - `max = a > b? a: b`​是C、Java的三元运算符, Python不支持
  
- 各运算符优先级: `括号`​>`幂`​>`位反`​>`正负号`​>`乘除余整`​>`加减`​>`位移`​>`位与`​>`位异或`​>`位或`​>`比较`​>`逻辑非`​>`逻辑与`​>`逻辑或`​

## 功能符

- 转义符: `\`

  - `\`: 可用作简单换行
  - `\u`: unicode码, 把u后面的4个字符解码, 无则报错
  - `\n`: 换行  
  - `\r`: 回车  
  - `\t`: 水平制表符
  - `\\`: 一个反斜杠`\` 
  - `\'`: 一个单引号,  `\"`: 一个双引号
  
- `r`符: 去除转义功能, 原样输出

- `f`符: 配合{}解析格式化输出

- `b`符: 声明字节类型

  ```python
  str1 = 'hello'
  str2 = b'hello'
  print(type(str1))	# class: str
  print(type(str2)) 	# class: bytes
  ```
  
- `%`占位符：

  - `%s`: 任意类型
  
  - `%d`: 整型
  
      - `%0nd`: 对填充的整数指定显式宽度
  
          - `n`显示宽度，`0`不足宽度则左侧填充0补齐
  
  - `%f`: 数字类型, 保留n位小数 `%.nf`​
  
  - 填充值与占位符一一对应, 填充多个值时数据值需要`()`包含

  - 可以在print函数中一起打印, 也可另起一行赋值
  
      ```python
      info = '%s的工资信息为: 基本工资%s, 绩效%s, 五险一金%s, 扣税%s, 实发工资%s'
      info = info % (name, bs, perf, issure, tax, ts)
      print(info)
      ```
  
- `*`解包：unpacking，可解包任意可迭代对象，如列表、元组、字符串、集合、字典

    - 装包：`b = 100, 'John'`

        - 含有`*args`​的情况: 按顺序每个键都要有值,  多余的给*

    - 解包：`a, b = (100, 'John')`

        - 解包可迭代对象, 相当于遍历
        - 解包字典用`**`，解出的是键
        - 集合解包后无序

## 改变作用域

- `global`: 于函数内修改函数外变量, 可变类型的修改不可添加global

    ```python
    def foo():
    	global a
    	a = 12
    	print(a)
    ```

- `nonlocal`: 主要用于闭包函数, 于内函数中修改外函数的变量值

    ```python
    nonlocal x
    x += 1
    ```



---



# 二、数据类型

## Num

- 整型`int`

  - 十进制, `int(num, base)`​转换十进制, base参数为原基数(无法转换'80.0' 无法转换'AB' , 可转换int('AB', 16)# 171)
  - 二进制: `0b`为前缀, `bin()`​
  - 八进制: `0o`为前缀, `oct()`​
  - 十六进制: `0x`为前缀, `hex()`​, 不区分大小写, a:10 b:11 c:12 d:13 e:14 f:15

- 布尔类型`bool`: 只有两个值True和False, **必须大写**，int子类, 可参与数学运算, 真1假0

- 浮点型`float`：Python只支持**双精度浮点**类型, 且须与本机相关

  - 运算中有浮点数, 则结果是浮点型
  - 科学计数法表示: `aen`，E/e表示底数10, n为指数, 即10的多少次方
  
- 复数类型`complex`: 字母j代替数学中虚数单位i

  ```python
  print(type(1+2j))   # complex
  ```

**魔法数字**：magic number, 在代码中直接使用的、无明确含义的数字/常量, 仿佛凭空出现, 让代码难以理解、维护，eg：`if score >= 60`，60即为魔法数字

- 用有意义的常量/枚举替代魔法数字:

  ```python
  PASSING_SCORE = 60
  
  if score >= PASSING_SCORE:
      print("Pass")
  else:
      print("Fail")
  ```
- 在枚举中替换魔法数字: 

  ```python
  from enum import Enum
  
  class Status(Enum):
      SUCCESS = 1
      ERROR = 2
      PENDING = 3
  
  def get_status_message(status):
      if status == Status.SUCCESS:
          return "Success"
      elif status == Status.ERROR:
          return "Error"
      elif status == Status.PENDING:
          return "Pending"
  ```

## Str

文本序列, 有序不可变, 修改只能重新赋值, 长度为1的称字符, 空格也是字符

- 创: 单引号、双引号、三引号、`str()`​

- 查: 

  - 切片: `字符串[开始下标: 结束下标: 步长]`​，`str[::]`​原样输出, `str[::-1]`​镜像输出
  - 查找：
  
    - `count("欲统计内容", 开始位置, 结束位置)`: 统计子串在指定字符串中出现次数, 不重叠
    - `find()`: 查找指定字符**第一次**出现位置下标, 无则返回-1
    - `rfind()`: 查找指定字符**最后一次**出现位置下标, 无则返回-1
    - `index()`: 类似find()函数, 无则报错
    - `rindex()`: 类似rfind, 无则报错
    - `max()`​、`min()`: 按ASCII码值比较大小, 逐个比较
  - 判断：
  
    - 英语&大小写：
  
      - `isupper()`: 检查字母是否全部大写;  其他字符不管, 只检查英语
      - `islower()`: 检查字母是否全部小写;  其他字符不管, 只检查英语
      - `istitle()`: 检查字符串中单词的首字母是否大写, 其他小写
      - 成员运算符方法 `if i in string.xxx`​：
  
        - 大写: `string.ascii_uppercase`​
        - 小写: `string.ascii_lowercase`​
        - 所有英文字母: `string.ascii_letters`​
    - 首尾：
  
      - `startswith(str/元组)`: 是否以指定字符集中任一字符开头
      - `endswith(str/元组)`: 是否以指定字符集中任一字符结尾
    - `isdigit()`​/`isnumeric()`: 检查是否全部为数字
    - 成员运算符方法: `in string.digits`​
    - `isalpha()`: 检查字符串是否全部为字母(各国)
  
      - 汉字: `if '\u4e00' <= a <= '\u9fa5'`​
      - 编码方法: `s.encode().isalpha()`: 纯英文字母
    - `isalnum()`: 是否是数字或字母(各国);  纯数字/纯字母/数字和字母
  
      - 编码方法: `s.encode().isalnum()`: 数字或英文字母
    - `isascii()`: 是否是ascii中的符号
    - `isspace()`: 是否是空白字符
  
- 改: 

  - 大小写转换：

    - 小转大: `upper()`​
    - 大转小: `lower()`​
    - 大小互换: `swapcase()`​
    - **每个**单词首字母大写并且其他小写: `tittle()`​，用不连续来区分单词
    - 整个字符串的**第一个**单词首字母大写并且其它全部小写`.capitalize()`​
  - 分割：

    - `split(sep=None, maxsplit=-1)`​ 以指定字符sep分割字符串, 默认以空白分割, 返回列表
    - \\t\\n\\r\\v\\f都是空白
      - maxsplit如省略, 则不限制分隔次数
    - `rsplit()`: 从右侧分割
    - `splitlines()`: 按行分割字符串,输出为['xxxxx', 'xxxxx', 'xxxxx']
  - 拼接：
  
  - `+`: eg: `"12" + "13" = "1213"`​
    - `.join()`: 以指定字符合并字符串, 被拼接的数据只能是字符串类型的
  
    ```python
      list1 = ["1", "2", "3", "4", "5"]
      pf = "-"
      print(pf.join(list1)) 		# 1-2-3-4-5
      print('-'.join(list1))
    ```
  
    - 推荐使用序列构建字符串: name = ''.join(char_list)
  - 填充：
  
    - `.center(n)`: 将字符串填充到指定长度, 默认空格填充, 原内容居中, 二参str指定填充符

      - print(str1.center(50))         # 填充到50个长度
    - print(str1.center(50,"\*"))     # 用\*填充到50个长度
    - `.ljust()`: 左对齐, 右侧填充, 默认空格
    - `.rjust()`: 右对齐, 左侧填充, 默认空格
    - `.zjust()`: 零填充, 0在左
  - 替换: `replace('旧', '新', 次数)`​, 无次数则全部替换
  - 编解码：编码和解码的方式要一致, 否则报错/乱码
  
    - ascii：
  
      - 对ascii中原有符号, 编码前后内容不变;  其他编码, 内容前有`\`​
      - `ord()`: 获取对应十进制数据
    - `chr()`: 获取对应字符
    - utf-8(一个汉字3个字节) gbk(一个汉字两个字节)
    
    - `encode(字符集)`: 以指定字符集编码
    - `decode(字符集)`: 以指定字符集解码

- 删: `strip()`​, 去除字符串两边指定字符, 默认空格

  - 不是整个进行检验, 而是一个字符一个字符的判断 遇到不匹配的字符就停止, 左边的从左到右去除, 右边的从右到左移除
  - `lstrip()`: 去除左边指定字符, 默认空格
  - `rstrip()`: 去除右边指定字符, 默认空格

## List

- 创：

  - `[]`​包含
  - `list()`: 参数必须为可迭代对象
  - `copy()`: 复制, 生成新列表
  - 切片复制: list1[::-1], 也生成新列表
  - 列表推导式: 

    - `[目标值 for i in range() if 条件]`​
    - `list(目标值 for i in range() if 条件)`​
- 查：

  - `count()`: 统计次数
  - `index()`: 返回元素的索引
  - 成员`in`​/`not in`​
  - 迭代用`enumerate:` 
  
    ```python
    fruits = ['orange', 'grape', 'pitaya', 'blueberry']
    for index, fruit in enumerate(fruits):
    	print(index, ':', fruit)
    ```
- 改：

  - `reverse()`: 翻转元素顺序, 改变原列表
  - `sort()`: 对元素排序, 默认升序, 改变原列表
- 降序: `.sort(reverse=True)`​
    - 注意与`sorted`的区分: sort只是list类型的方法, sorted是高阶函数, 可对任意序列排序 sort改变原数据, sorted生成新数据
- 注意有负数的情况, 必要时使用abs()
  - `insert(下标, 内容)`​ 此时下标不能为负, eg: list1.insert(2, 'a')
  - `append()`: 尾部追加单个元素
  
    - 也可使用运算符+/+\=, 但单个元素必须用[]包含
  - 若append列表, 则将列表作为一个元素追加
  - `extend(序列)`: 添加多个元素, 必须为序列，会直接修改原列表，不生成新列表
  - **+或+\=: 合并**,+会返回一个新对象
  - \*或\*\=: 重复, 右操作数为次数
  - 修改切片
  
    - 切片连续: `list[-3:] = [98, 99, 100]`​ 右侧必须是可迭代数据
  - 切片不连续: 需要新赋值和获取数量一致
- 删：

  - `pop(下标)`: 删除指定位置的元素, 默认为最后一个元素, 返回原列表
  - `remove(元素)`: 若有重复, 只能删除找到的第一个

    - 易错点: 因为列表的可变性, 在遍历的同时删除, 原列表发生变化, 继续遍历会漏掉一些元素

      解决: `for i in list[:]或list.copy()`​ 从镜像中遍历, 从原表中删除
  - `clear()`: 清空列表, 保留空列表

## Tuple

有序不可变, 可嵌套元组, 占内存比列表少

- 创：

  - `tuple()`​
  - `()`包含：有时小括号可省略，只有一个元素时, 必须加一个逗号表示元组, 若不加逗号, 则根据元素的类型决定数据类型
- 查：
  - 判断: `in`​/`not in`​
  - 比较: 相同位置逐个比较
- 改: 合并: +, 重复: \*
- 删: del 元组: 删除元组, 释放内存, 再次引用会报错

## Dict

- 创：

  - `{}`​, key和value组成
    - `{key1: value1, key2: value2, ……}`中间逗号隔开
    - 键不能重复, 重复后覆盖前, 键的数据类型为不可变的类型, 如不能为列表
  - `dict()`​：
    - `dict(键1:值1, 键2:值2……)`​
    - `dict(变量1=值1,  变量2=值2……)`​,此处变量名不可加引号
    
    - `dict([(键, 值), (键, 值), (键, 值)])`​
    - `dict(zip( [*键], [*值] ))`​, 键值数量不一致时, 以少的为准
  - 字典推导式: 
  
    - `{ k: v for k, v in 字典.items() if 条件 }`​, 此处必须放键值对
    - `dict((k, v) for k, v in 字典 if 条件)`​, 此处不能放键值对
    - 建议先把键定义出来
  - `dict.fromkeys(序列, 自定义值)`: 根据键快速制作一个字典, 值默认为None, 也可自定义
  - `copy()`: 复制
- 查：

  - 访问值: 根据键获取值, 成员运算针对键, 不能用下标/值定位元素

    - `字典名[键]`​, 访问不存在的key会报错
    - `字典.get(键, 不存在时返回值)`​, 不存在时默认返回None
  - `values()`: 获取所有value
  - `keys()`: 获取所有key
  - `items()`: 获取所有键值对
  - `len()`: 获取字典元素的个数
  - 遍历：

    - `for i in dict:`​, 获取的仅为键
    - `for v in dict.values( ):`​, 获取的仅为值
    - `for k, v in enumerate(dict):`​, 返回索引和键, 而不是键值对
    - `for k, v in dict.items( ):`​, 返回元组形式
  - 词频统计: 

    ```python
    from collections import Counter
    print (Counter(str1))
    ```
- 改：

  - 增: `字典名[键] = 值`​, (原字典中无该键)
  - 改: `字典名[键] = 值`​, (原字典中有该键)
  - 增改: `setdefault(键, 值)`​, 有则不动, 无则增加
  - 合并: `update(序列)`​, 可为字典、键值对、变量\=值、元组/二维数据、zip()
- 删：

  - `del 字典[键]`​
  - `pop(键)`​
  - `popitem()`: 默认删除最后一个元素
  - `clear()`: 清空字典, 保留字典结构

## Set

- 创：

  - `set()`​
  - `{}`​包含, 不能构建空集合, 空集合为`set()`​
  - `copy()`: 复制(copy函数可用于列表、字典、集合等可变类型)
  - 集合推导式
- 查：

  - 成员运算: `in`​/`not in`​
  - 比较: 返回布尔值
  
    - 易错: 集合的比较不同于其他类型, **不是逐一比较**
    - \>: 包含, 超集
    - \<: 被包含, 真子集
    - \<\=: 子集, 不一定是真子集
    - \>\=: 包含, 不一定真包含
    - \=\=、!\=
  - 判断：
  
    - `isdisjoint()`: 是否无交集, 无交集返回True
    - `s1.issubset(s2)`: s1是否被s2包含, 可以全等
    - `s1.issuperset(s2)`: s1是否包含s2, 可以全等
- 改：

  - 增：

    - `add()`: 添加单个元素, 若已存在会报错
    - `update()`: 以列表形式添加多个元素
  - 算：

    - 交集: `a & b`​等同于`a.intersection(b)`​

      `a &= b`​等同于`a.intersection_update(b)`: 改变原集合, 把交集赋值给a
    - 并集: `a | b`​ 等同于`a.union(b)`​

      `a |= b`: 并集并改变原集合
    - 差集: `a - b`​等同于`a.difference(b)`​, 不满足交换律

      `a -= b`: 差集并改变原集合
    - 对称差集: `a ^ b`​等同于`a.symmertric_difference(b)`​, 并集 - 交集

      `a ^= b`​等同于`a.symmertric_difference_update(b)`​, 改变原集合, 把对称差集赋值给a
    - 非: `~`
- 删：

  - `pop()`: 随机删除一个元素
  - `remove()`: 删除指定元素,不存在会报错
  - `discard()`: 删除指定元素, 不存在不报错
  - `clear()`: 清空集合, 保留结构

## 类型转换

- 隐式转换: 布尔 + 整型 = 整型, 布尔/整型 + 浮点 = 浮点
- 显式转换: `int()`、`float()`、`bool()`、`set()`、`dict()`、`str()`、`list()`、`tuple()`

    - int(x, base = 10), base为进制数, 默认十进制, 浮点数会截断小数部分
    - float(): 不能转换非数字类型
    - bool(): `无参数`​、`0`​、`0.0`​、`空字符串`​、`空列表`​、`空元组`​、`空集合`​、`空字典`​、`None`​返回false

## 特殊类型

- 空值None: 只有一个值None, 类型为Nonetype

- 可迭代对象：可逐一返回其成员对象, 可迭代协议`__iter__()`, 本身不能返回元素, 只是一个容器

- 迭代器：

    - `iter(callable, sentinel)`: 返回一个迭代器

        - callable: 一个可调用的对象, 如函数或lambda
        - sentiel: 停止值, 当callable返回此值时, 迭代结束, 可取代while循环

        ```python
        def reader(s):
        	for chunk in iter(lambda: s.recv(CHUNKSIZE), b''):
        		process_data(data)
        ```

    - `next()`：显式获取下一元素

    ```python
    numbers = [1, 2, 3, 4]
    iterator = iter(numbers)  # 获取迭代器
    
    # 使用for循环迭代
    for i in iterator:   	# for循环在后台自动用next()处理, 直到触发异常为止, 所以for循环不需next()	
    	print(i)
    
    # 使用 next() 显式获取元素
    print(next(iterator))  # 输出 1
    print(next(iterator))  # 输出 2
    print(next(iterator))  # 输出 3
    print(next(iterator))  # 输出 4
    # 再调用 next() 会抛出 StopIteration 异常
    
    try:
        print(next(iterator))  # 会抛出 StopIteration
    except StopIteration:
        print("Iteration is complete!")
    ```

- 生成器：推荐多用

    - 创：生成器表达式（列表推导式的`[]`变成`()`）或函数+yield

    - `next(gen)`: 获取下一个值，`gen.next()`​方法已废弃

    - `gen.send()`: 向生成器内部发送一个值**成为yield表达式的结果**，并继续执行生成器的代码

        - :warning:易混淆, `a = yield b`​, 生成b后暂停，a接受`send()`

        ```python
        def calc_avg():
            """流式计算平均值"""
            total, counter = 0, 0
            avg_value = None
            while True:
                value = yield avg_value 	# 生成avg_value后暂停, value接受send()
                total, counter = total + value, counter + 1
                avg_value = total / counter
                
        gen = calc_avg()
        next(gen)
        print(gen.send(10)) 	# 10被赋值给value
        print(gen.send(20))
        print(gen.send(30))
        ```

    - `gen.throw(exception_type, value=None, traceback=None)`: 向生成器抛出一个异常, 生成器可捕获处理或继续抛出

      - `gen.close()`: 关闭生成器, 触发`GeneratorExit`​异常, 关闭后无法再通过`next()`​获取值

      - `yield from <iterable>`: 简化生成器委托, 把一个生成器的输出直接传递给外部调用者, 减少编写`for`循环和手动调用yield

        ```python
        def num_generator(m, n):
        	yield from range(m, n + 1)
        ```

        - 可传递子生成器的返回值和异常

      - 使用场景：

        - 处理大型数据集(节省内存):

            ```python
            # 逐行读取文件
            def read_large_file(file_path):
                with open(file_path, 'r') as file:
                    for line in file:
                        yield line  # 每次返回一行内容
            
            # 使用生成器逐行读取文件, 避免一次性将整个文件加载到内存
            for line in read_large_file('large_file.txt'):
                process(line)  # 逐行处理文件内容
            ```

        - 无限序列生成:

            ```python
            # 生成无限数字序列
            def infinite_counter(start=0):
                count = start
                while True:
                    yield count  # 每次返回一个新的数字
                    count += 1
            
            # 生成无限的数字序列
            counter = infinite_counter()
            for _ in range(10):
                print(next(counter))  # 输出 0 1 2 3 4 5 6 7 8 9
            
            # Fibonacci
            def fibonacci():
            	a, b = 0, 1
            	while True:
            		yield b
            		a, b = b, a + b
            
            fib = fibonacci()
            ```

        - 生成组合或排列:

            ```python
            # 生成所有排列
            import itertools
            
            def generate_permutations(iterable):
                for item in itertools.permutations(iterable):
                    yield item
            
            # 生成所有字符的排列
            for perm in generate_permutations('AB'):
                print(perm)
            ```

        - 管道式数据处理: 在多个处理步骤之间进行数据的传递和处理, 例如, 数据从一个生成器流到下一个生成器, 每个生成器执行某一特定的转换操作

            ```python
            def read_lines(file_path):
                with open(file_path) as f:
                    for line in f:
                        yield line.strip()
            
            def filter_lines(lines, keyword):
                for line in lines:
                    if keyword in line:
                        yield line
            
            def process_lines(lines):
                for line in lines:
                    yield line.upper()
            
            # 使用生成器管道处理文件
            file_lines = read_lines('data.txt')
            filtered_lines = filter_lines(file_lines, 'important')
            processed_lines = process_lines(filtered_lines)
            
            for line in processed_lines:
                print(line)
            ```

        - 批处理数据: 数据需要被分成小批次处理(例如机器学习中的数据加载)

            ```python
            def batch_generator(data, batch_size):
                for i in range(0, len(data), batch_size):
                    yield data[i:i + batch_size]
            
            # 假设我们有一个大数据集
            data = [i for i in range(100)]
            
            # 使用生成器按批次处理数据
            for batch in batch_generator(data, 10):
                print(batch)  # 每次输出一个包含 10 个元素的子列表
            ```

        - 延迟计算：

            ```python
            def lazy_square(n):
                for i in range(n):
                    yield i * i  # 每次返回一个平方值
            
            # 生成一个懒加载的平方数序列
            for value in lazy_square(5):
                print(value)  # 输出 0, 1, 4, 9, 16
            ```

          - 流式数据处理: 如处理网络请求、实时数据流, 允许一边接收数据一边处理数据, 避免在内存中存储大量中间数据

            ```python
            import time
            
            def simulate_data_stream():
                for i in range(10):
                    time.sleep(1)  # 模拟延迟
                    yield i  # 每秒钟生成一个新的数据
            
            # 实时处理数据流
            for data in simulate_data_stream():
                print(f"Received data: {data}")
            ```




---

‍

# 三、流程控制

## 顺序结构

从头到尾, 不重复, 不跳过

`pass`关键字: 无实际意义, 占位, 保证语法完整, 不输出

## 选择(分支)结构

- 单分支语句: `if`​, 注意if句后的冒号 表达式不成立时, 不执行语句
- 双分支语句: `if else`​，可使用三元运算符简化: `max = a if a > b else b`​

- 多分支语句: `if elif else`​从上往下匹配条件, 否则执行else语句
- 分支嵌套

## 循环结构

- while: 初始表达式只执行一次, 条件不满足时, 跳出整个循环

  - 可有else: 若执行break则不执行else, 未执行break则执行else
- for循环:

  - i不使用时可用`for _ in ...`​
  - for-in-else循环: 循环正常结束时执行else

- break: 用于跳出整个循环, 即结束while
- continue: 跳出当前循环, 不执行更新条件, 执行下一个while
- 死循环: 一般用while循环实现: `while True`​或`while 1`​
- 循环嵌套: 一般循环嵌套不超过三层, 双重循环中, 一般外层控制行数, 内层控制列数

‍

---

‍

# 四、函数

```python
def 函数名():			# 函数名遵循标识符命名规则, 重名则后覆盖前
	函数体
	[return 返回值]

# 带元信息
def 函数名(params: type) -> type: 		# type指明参数类型和返回值类型
	'''
	comment						# 写函数含义注释
	:param参数名:				# 写参数释义, 可有多行
	:return:					# 写返回值释义
	'''
	函数体
	[return 返回值]
```

- 可像变量一样赋值后调用：

    ```python
    def myprint():
    	pass
    t = myprint
    t() 	# 调用t()
    
    # getattr返回md5函数对象, 最后的括号则调用md5()
    self.hasher = getattr(__import__('hashlib'), alg.lower())()
    ```

- 参数: `()`为参数列表, 可为空，要求独立参数，不独立时需使用*拆包

  - 必须参数/位置参数: 调用时必须以正确顺序传参, 形实数量一致, 否则报错
  - 关键字参数: 允许形实乱序, 自动匹配
  - 默认参数: 定义时给形参的默认值, 无实参则使用默认值, 有实参则覆盖默认值
  
    - 参数列表中若有默认参数, 应放在最后, 否则报错
  - 不定长参数(可变参数): 必须放在普通参数之后
  
    - \*args: 接收多个位置参数, 得到参数为元组
    - \*\*kwargs: 接收多个关键字参数, 得到参数为字典形式, 传入时使用键值对形式(k \= v)
  - 命名式关键字参数: 限制只能使用关键字方式传参, 若形参中有\*, <u>*后面的必须用关键字参数传参</u>, 而不能用位置传参, 调用函数时必须明确参数名
  
    ```python
    def greet(name, age, *, country='China'):
    	pass
    
    greet('Alice', 30, country='USA') 	# *后的参数必须用关键字传参
    ```
  
- 返回值: 默认返回None

  - 可一次返回多个数据, 以元组形式保存
- 若出现return, return后面的程序(同层级)不会执行

## 内置函数

- `input()`: 接收类型为str, 程序在input函数暂停等待, 输入并回车后继续

- `eval()`: 解析字符串, 转变成数据对应的类型, 如将字符串'10'转变为int类型10

  - 应尽量**避免使用**，会执行任意传入的字符串作为代码, 且执行效率低于静态代码

    ```python
    user_input = "__import__('os').system('rm -rf /')"
    eval(user_input)
    ```
  - 替代：`ast.literal_eval()`​，仅支持字面量，如数字、字符串、列表、字典等，不执行代码
  
- `print()`: 参数: 

  - `self`: 类名, 一般指当前类
  - `*args`: 可变参数, 可以是多个, 表示要输出的数据
  - `sep`: 输出多个数据时数据的间隔, 默认为空格
  - `end`: 输出完毕后的结尾符号, 默认为\\n(技巧: 利用`print()`​换行)
  - `file`: 表示文件名称, 默认为控制台
  
- `range([start], end, [step])`​

  - `start`: 开始值, 包含, 可选, 默认为0
  - `end`: 结束值, **不包含**, 可选
  - `step`: 步长值, 两值间隔, 默认为1

  - 不能直接print, 须借助`list()`​函数 (将其他类型数据转换为列表)
  
- `format()`: 格式化函数, `f'{}'`​更简单

  - 不设定指定位置, 按照默认位置: 

    ```python
    print('{} {} {}'.format('i', 'am', 'Groot'))
    ```
  - 设定指定位置(下标): 

    ```python
    print('{1} {2} {0}'.format('Groot', 'i', 'am'))
    ```

    ![截屏2024-12-25 14.33.57](../assets/截屏2024-12-25%2014.33.57-20241225143400-bjpm5i3.png)​
  - 直接设定参数: 

    ```python
    print('{Subject} {Verb} {Object}'.format(Subject='i', Verb='am', Object='Groot'))
    ```
  - 通过字典设定参数: 

    ```python
    dir_case = {'Subject':'i', 'Verb':'am', 'Object':'Groot'} 
    print('{Subject} {Verb} {Object}'.format(**dir_case))
    ```
  - 通过列表设定参数: 

    ```python
    list_case1 = ['i', 'am'] 
    list_case2 = ['Groot'] 
    print('Subject:{0[0]} Verb:{0[1]} Object:{1[0]}'.format(list_case1, list_case2))
    ```
  - 通过对象设定参数: 

    ```python
    class setValue(object): 
    	def __init__(self, value):
    		self.value = value  
    
    my_value1 = setValue('i am Groot') 
    print('value1是: {0.value}'.format(my_value1))
    ```
  - 格式化控制符: 

    语法: `{参数序号/参数名: [填充符][对齐方式][宽度]}`​

    ![截屏2024-12-25 14.35.44](../assets/截屏2024-12-25%2014.35.44-20241225143547-v7jo88j.png)​

    ```python
    print('数字为: {:.3f}'.format(3.1415))
    ```

    ![截屏2024-12-25 14.27.11](../assets/截屏2024-12-25%2014.27.11-20241225142714-ycg5k8w.png)

    - `^`​, `<`​, `>`​分别是居中、左对齐、右对齐, 后面带宽度
    - `:`​修饰符, 后面带填充的字符, 只能是一个字符, 不指定则默认空格填充
    - `+`​表示在正数前显示+, 负数前显示-
    - `空格`​表示在正数前加空格
    - `{x=}`：=表示输出变量名及其值
    - b、d、o、x、X: 二进制、十进制、八进制、十六进制(小写)、十六进制(大写)
    - s: 字符串
    - f/F: 十进制浮点数, g/G: 十进制整数或浮点数, e/E: 科学计数法表示浮点数
  - 格式化指令: 
  
    - `!s`: 调用值的`__str()__`​, 将值转为字符串
  
      ```python
      print('Value: {!s}'.format(value))
      # 也可用
      print(f'Value: {value!r}')
      ```
    - `!r`: 调用值的`__repr()__`​, 将值转为'官方字符串表示形式'
  
      ```python
      print('Value: {!r}'.format(value))
      ```
    - `!a`: 调用值的`__ascii()__`​, 将值转为ASCII编码的字符串表示形式
  
      ```python
      print('Value: {!a}'.format(value))
      ```
  - 采用{}转义: 
  
    ```python
    print ("{} 是 {{银护的台词}}".format("i am Groot")) 	# i am Groot 是 {银护的台词}
    ```
  
- `enumerete()`: 枚举函数，二参为start位置

    ```python
    for k, v in enumerate(str1):
        print(k, v, end='*')
    ```

- `abs()`: 求绝对值

- `pow(base, exp, mod)`: 求幂

## 匿名函数

`lambda 参数列表: lambda体`，参数列表不用小括号

简单清晰, 一般只有一行, 不能包含多条语句，一般使用变量接收

结果返回给`lambda()`​, 不用return

可没有参数, 仅作为函数的'调用器': `lambda: stream.read(self.size)`​

```python
test = lambda x, y: x * y 
print(test(12, 4))

# 基于递归和欧几里得算法找到x和y的最大公约数
gcd = lambda x, y: gcd(y, x) if x > y else (y % x and gcd(y % x, x) or x)

# 结合__import__函数计算阶乘(不推荐)
fac = lambda x: __import__('functools').reduce(int.__mul__, range(1, x + 1), 1)
# __import__('module_name')动态加载模块, 不是语句, 是函数
# int.__mul__: Python乘法运算符*的底层实现

# lambda仅调用函数
for buf in iter(lambda: stream.read(self.size), b''):
# 每次迭代都调用lambda, 并将结果和b''比较(表示数据流读取完毕), True则停止迭代
```

## 回调函数

把函数1作为参数传到函数2中, 函数1即为回调函数, 常用于高阶函数：

- `map(func, iterable)`: 映射

  - func为自定义操作函数, 返回变换之后的元素
  - iterable为容器型数据
- `filter(func/None, iterable)`: 过滤

  - func为过滤条件函数, 返回布尔值
  - None为不设置任何函数处理, 仅布尔取值, 过滤了为False的数据
  - iterable为容器型数据
- `functools.reduce(func, sequence)`​

  - 累计汇总, 对序列中的数据按指定功能进行汇总操作
  - 需要`import functools`​

    ```python
    reduce(lambda x, y: x+y, [1, 2, 3, 4, 5])
    ```
- `max(容器, key=函数)`​
- `min(容器, key=函数)`​
- `sorted(序列, key, reverse)`: 排序,  **默认升序**, 返回新列表, 不改变原数据

  - 降序: `list3 = sorted(list1, reverse=True)`​
  - `key=排序规则`: 可传递函数, 如`len()`​或者lambda等

## 闭包closure

```python
# 一个简单的闭包
# 定义了一个变量x, 并返回inner_function
def outer_function(x):
	# 使用了外层函数的变量x
    def inner_function(y):
        return x + y  # 内层函数引用了外层函数的变量 x
    return inner_function

# 创建一个闭包
closure = outer_function(10) 	# 返回inner_function, 并记住x=10

# 调用闭包
print(closure(5))  # 输出 15

# 用闭包保存状态, 可创建带有记忆功能的函数
def make_counter():
    count = 0  # 外层变量

    def counter():
        nonlocal count  # 修改外层变量
        count += 1
        return count

    return counter

# 创建计数器
counter1 = make_counter() 	# 每个make_counter调用都会创建一个新的闭包
counter2 = make_counter()	# counter1和counter2是独立的闭包, 互不影响

print(counter1())  # 输出 1
print(counter1())  # 输出 2
print(counter2())  # 输出 1
```

**应用场景：**

1. 数据封装: 使用闭包可以创建私有变量, 只能通过闭包内的函数访问

    ```python
    def make_account(balance):
        def withdraw(amount):
            nonlocal balance
            if balance >= amount:
                balance -= amount
                return balance
            else:
                return "余额不足"
        return withdraw
    
    my_account = make_account(100)
    print(my_account(50))  # 输出 50
    print(my_account(60))  # 输出 "余额不足"
    ```
2. 回调函数: 闭包可以用于传递回调函数, 记住上下文环境
3. 装饰器: 闭包是实现装饰器的基础, 用来为函数动态添加功能

## 装饰器

**结构:**

```python
def decorator(func): 	# func即被装饰的函数
    def wrapper(*args, **kwargs):	# 包装函数, 在此添加额外功能
        # 在调用原函数之前可以执行一些操作
        do Something
        # 调用原函数
        result = func(*args, **kwargs)
        # 在调用原函数之后可以执行一些操作
        do Something
        return result
    return wrapper
```

**使用:** `@decorator_name`​置于函数定义上一行

**带参数的装饰器**(装饰器本身有参数):

```python
# 接受一个times参数, 返回一个装饰器
def repeat(times):		# 装饰器工厂, 用来生成装饰器
	# 接受一个func参数, 返回一个包装函数
    def decorator(func):
        def wrapper(*args, **kwargs):
            for _ in range(times):
                func(*args, **kwargs)
        return wrapper
    return decorator

@repeat(times=3)
def greet():		# 实际上被替换为wrapper函数
    print("Hello!")

greet()
```

**应用场景:**

- 日志记录:

  ```python
  def log(func):
      def wrapper(*args, **kwargs):
          print(f"Function {func.__name__} is called with {args}, {kwargs}")
          return func(*args, **kwargs)
      return wrapper
  
  @log
  def multiply(a, b):
      return a * b
  
  print(multiply(2, 5))
  ```
- 权限验证:

  ```python
  def require_auth(func):
      def wrapper(user, *args, **kwargs):
          if not user.get("is_admin"):
              print("Access denied.")
              return None
          return func(user, *args, **kwargs)
      return wrapper
  
  @require_auth
  def delete_user(user, user_id):
      print(f"User {user_id} has been deleted.")
  
  # 示例
  admin = {"username": "admin", "is_admin": True}
  guest = {"username": "guest", "is_admin": False}
  
  delete_user(admin, 123)  # 有权限
  delete_user(guest, 456)  # 无权限
  
  # ------------------------------ # 
  # 输出
  User 123 has been deleted.
  Access denied.
  ```
- 缓存结果: 将最近调用的输入参数及结果缓存, 极大的提高效率, 若有新的调用, 先检查缓存, 维护一个固定大小的有序字典, 存储参数和对应的返回值

  ```python
  def cache(func):
      cached_results = {}
  
      def wrapper(*args):
          if args in cached_results:
              print("Fetching from cache...")
              return cached_results[args]
          result = func(*args)
          cached_results[args] = result
          return result
      return wrapper
  
  @cache
  def fibonacci(n):
      if n <= 1:
          return n
      return fibonacci(n - 1) + fibonacci(n - 2)
  
  print(fibonacci(10))  # 计算并缓存结果
  print(fibonacci(10))  # 从缓存中获取
  ```

  - `@lru_cache`: Least Recently Used cache缓存装饰器, maxsize指定缓存的最大条目数

    ```python
    from functiontools import lru_cache
    
    @lru_cache(maxsize=256)  
    def fib(n): 
    	if n in (1, 2): 
    		return 1 
    	return fib(n - 1) + fib(n - 2)
    ```
- 确保枚举唯一: `@unique`​, 修饰枚举类, 若枚举类中有重复值, 会抛出ValueError异常, 枚举成员之间**只能用is比较**, 不能用==

  ```python
  from enum import Enum, unique
  
  @unique
  class Color(Enum):	# 继承Enum表示定义的是一个枚举类, 包含一组有意义的常量集合, 但不保证唯一性
  	RED = 1			# Enum允许多个枚举成员有相同值
  	GREEN = 2
  	BLUE = 3
  ```
- 加速计算：`@jit`​，即时编译，将数值函数编译成接近机器语言的高效代码

  函数必须是数值密集型、循环密集型才有效果，不支持所有Python特性（复杂类，字符串操作等），第一次运行慢（编译），推荐`nopython=True`​，否则会自动fallback到Python模式，提升不大

  ```python
  @jit(nopython=True)
  def foo(x):
  	pass
  ```
- 实现单例模式:

  ```python
  def singleton(cls):
      """装饰类的装饰器"""
      instances = {}
  
      @wraps(cls)
      def wrapper(*args, **kwargs):
          if cls not in instances:
              instances[cls] = cls(*args, **kwargs)
          return instances[cls]
  
      return wrapper
  
  @singleton
  class President:
      """总统(单例类)"""
      pass
  
  # 线程安全的单例装饰器
  from functools import wraps
  form threading import RLock
  def singleton(cls):
      """线程安全的单例装饰器"""
      instances = {}
      locker = RLock()
  
      @wraps(cls)
      def wrapper(*args, **kwargs):
          if cls not in instances: 	# 检查两次比先锁后查性能更好
              with locker:		# 锁对象本就是上下文管理器对象
                  if cls not in instances: 
                      instances[cls] = cls(*args, **kwargs)
          return instances[cls]
  
      return wrapper

- `@wraps(func)`: 装饰器会覆盖原函数的元信息(函数名`__name__`​、函数文档字符串`__doc__`​、函数注解`__annotations`​), `functools.wraps`​可将原函数的元信息保留在包装函数中

  ```python
  from functools import wraps
  
  def decorator(func):
      @wraps(func)
      def wrapper(*args, **kwargs):
          return func(*args, **kwargs)
      return wrapper
  
  @decorator
  def my_function():
      """This is my_function."""
      pass
  
  print(my_function.__name__)  # 输出: my_function
  print(my_function.__doc__)   # 输出: This is my_function.
  ```

  - `@wraps`​工作原理: 将func的元信息复制到包装函数, 并设一个属性`__wrapped__`​指向原函数`func`​

    ```python
    def wraps(func):
        def decorator(wrapper):
            wrapper.__name__ = func.__name__
            wrapper.__doc__ = func.__doc__
            wrapper.__annotations__ = func.__annotations__
            wrapper.__wrapped__ = func
            return wrapper
        return decorator
    ```
  - 使用装饰器后, 原函数文档可通过help函数查看
  - 可通过`func.__wrapped__`​方式获得被装饰之前的函数/类

## 递归函数

函数调用自身

**实现递归的思路:** 

- 找到临界值(临界条件), 如0, 1
- 找到两个循环间的关系
- 总结规律

**注意:** 

- 一定要有基例(出口, 已知项)
- 嵌套的层次不可太深(占用内存)



---



# 五、虚拟环境

管理工具：`vitualenv`、`venv+pip`、`pipenv`、`uv venv`、`conda`

|                             | **virtualenv**                         | **venv**                      | **pipenv**                       | **uv**                                      | **conda/mamba**                                |
| :-------------------------- | :------------------------------------- | :---------------------------- | :------------------------------- | :------------------------------------------ | :--------------------------------------------- |
| **核心**                    | 第三方工具，先于`venv`，旧版Python兼容 | **Python 标准库 (3.3+)**      | 第三方工具，项目依赖管理         | 第三方工具，**极速环境+包管理**，现代，Rust | 第三方工具，**跨语言包/环境管理/数据科学生态** |
| **安装方式**                | `pip install virtualenv`               | **无需安装**                  | `pip install pipenv`             | `pip install uv`                            | **独立安装**                                   |
| **Python 2.7/3.0-3.2 支持** | ✅                                      | ❌                             | ❌                                | ❌                                           | ❌ (仅支持 Python 3.x)                          |
| **管理 Python 解释器版本**  | ⚠️ 通过 `-p` 指定路径                   | ❌                             | ❌ (依赖系统 PATH 中的版本)       | ❌                                           | ✅ (核心功能)                                   |
| **创建环境命令**            | `virtualenv [name]`                    | `python -m venv [name]`       | `pipenv --python 3.10`           | `uv venv [name]`                            | `conda create -n [name] python=3.10`           |
| **依赖文件格式**            | `requirements.txt` (手动生成)          | `requirements.txt` (手动生成) | **`Pipfile` + `Pipfile.lock`**   | `requirements.txt`/`pyproject.toml`         | **`environment.yml`**                          |
| **依赖安装命令**            | `pip install [pkg]`                    | `pip install [pkg]`           | `pipenv install [pkg]`           | **`uv pip install [pkg]`**                  | `conda install [pkg]`                          |
| **依赖解析速度**            | 中等                                   | 中等                          | ⚠️ **历史较慢** (已优化但不如 uv) | ✅✅✅ **极快** (Rust 并行解析)                | 中等 (`mamba` 比 `conda` **快数倍**)           |
| **解决复杂依赖冲突能力**    | ❌ (依赖 pip)                           | ❌ (依赖 pip)                  | ✅ (优于纯 pip)                   | ✅ (优于 pip)                                | ✅✅ **最强** (尤其非 Python 包)                 |
| **管理非 Python 包**        | ❌                                      | ❌                             | ❌                                | ❌                                           | ✅ (C/C++ 库、R 包等)                           |
| **跨平台支持**              | 优秀                                   | 优秀                          | 优秀                             | 优秀                                        | **最统一** (尤其对 Windows 友好)               |
| **虚拟环境位置**            | 项目目录或全局                         | 项目目录或全局                | 项目目录或全局                   | 项目目录或全局                              | **全局集中管理** (`envs/` 目录下)              |
| **激活环境命令**            | `source <path>/bin/activate`           | 同 virtualenv                 | `pipenv shell`                   | 同 venv/virtualenv                          | `conda activate [name]`                        |
| **环境列表查看**            | 需手动管理目录                         | 需手动管理目录                | `pipenv --venv`                  | 需手动管理目录                              | ✅ `conda env list`                             |
| **删除环境方式**            | **删除目录**                           | **删除目录**                  | `pipenv --rm`                    | **删除目录**                                | ✅ `conda remove -n [name] --all`               |
| **推荐指数**                | ⚠️ **仅旧版项目**                       | ✅ **Python 项目首选**         | ❌ **不推荐新项目**               | ✅✅ **现代项目强推**                         | ✅✅ **数据科学必备**                            |
| **核心优势**                | 唯一兼容 Python 2.7 和 < 3.3           | 内置免安装、标准轻量          | 锁版本 + 依赖文件自动管理        | **速度碾压级快**、整合 Pip/Cargo            | 跨语言 + 解决复杂依赖 + 预编译包               |
| **典型使用场景**            | 维护 Python 2.7 / 旧系统项目           | 一般 Python 项目、Web 开发    | 遗留 Pipfile 项目                | **任何追求效率的 Python 环境**              | 数据科学、机器学习、跨语言研究                 |

## vitualenv

**历史地位**: Python 虚拟环境的**元老级工具**， `venv` 的前身和灵感来源，Python 3.3 之前创建虚拟环境的**唯一**主流选择

**最大优势**：支持旧版 Python，额外功能选项较多

**使用场景**: 维护需要 Python 2.7 或 Python < 3.3 的遗留项目，不可替代

## venv + pip

Python 3.3 引入了 `venv` 模块（基于 `virtualenv` 的核心思想），作为标准库的一部分

首推，适用于大多数Python项目

- **官方内置:** Python 3.3+ 自带，无需额外安装
- **轻量简洁:** 只专注于创建隔离的Python环境
- **稳定可靠:** 作为标准工具，兼容性最佳
- **与`pip`完美配合:** Python官方的包管理器

常用命令:

```shell
python -m venv .venv	# 创建环境
source .venv/bin/activate	# 激活环境
deactivate		# 停用环境

pip -V  	# 查看pip版本
pip list 	# 查看所有已安装包
pip install -upgrade pip	# 更新pip

pip install <包名>[==<版本号>]		# 若未指定版本, 默认安装最新版
pip install 模块名 -i https://pypi.douban.com/simple/ 	# 指定镜像源安装
pip uninstall <包名>		# 卸载

pip install -r requirements.txt		# 批量安装依赖
pip freeze > requirements.txt 	# 导出依赖文件

# 设置临时国内镜像
pip config set global.index-url https://mirrors.aliyun.com/pypi/simple/
# 设置永久镜像源
Vim ~/.pip/pip.conf
```

**删除环境:** 直接删除对应的环境文件夹即可 (无需特殊命令)

## pipenv

旨在结合`pip`和`virtualenv`，并引入类似Ruby `bundler`或Node `npm`的项目依赖管理（自动生成`Pipfile`和`Pipfile.lock`)

## uv

一体化工具链， `uv venv` 负责环境管理，`uv pip` 负责包管理（完全兼容`pip`命令），用 Rust 编写，包安装速度远超 `pip` 和 `pip-tools`，内存占用极低，环境创建极快，完美跨平台，**兼容`requirements.txt`和`pyproject.toml`**

安装: `pip install uv`

常用命令：

```shell
# uv venv
uv venv .venv	# 创建虚拟环境
uv venv -p python3.11 .venv	# 指定python版本创建
uv venv --recreate .venv	# 重建损坏的环境
source .venv/bin/activate	# 激活环境
deactivate	# 停用环境

# uv pip
uv pip install <包名>		# 安装
uv pip install -i https://... <包名>
uv pip install -r requirements.txt	# 批量安装依赖
uv pip uninstall <包名>	# 卸载

uv pip freeze > requirements.txt	# 导出依赖文件

uv pip list		# 查看已安装包
uv pip list --outdated 		# 检查可更新的包
```

删除环境: 直接删除环境文件夹

## conda

- **超越Python:** 管理 Python 解释器本身、Python包、二进制库 (R, C/C++, Fortran编译器等)

- **强大的预编译包库:** Anaconda Repository/Cloud 提供大量预编译好的科学计算包 (避免复杂编译)

- **跨平台:** Windows, macOS, Linux 体验一致

- **解决环境冲突能力强:** 优秀的依赖解析器 (尤其是 `mamba`)

- mamba：`conda` 的 C++ 重写替代品，安装和使用命令几乎与`conda`相同，但**更快**🚀、**依赖解析更强更稳定**

- 频道 (Channels): 包来源，默认频道往往不够用，特别是科学计算包
    - **强烈建议优先使用`conda-forge`频道：** 
    
        ```shell
        conda config --add channels conda-forge
        conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/
        conda config --set channel_priority strict	# 使用mamba时自动优化
        ```

常用命令：

```shell
# 以下命令中`conda`均可替换为`mamba`以获得更快速度

# 创建环境并指定 Python 版本：
conda create -n myenv python=3.10
# 创建环境并同时安装包:
conda create -n myenv python=3.10 numpy pandas matplotlib scikit-learn
# 克隆环境
conda create --name <new> --clone <old>

# 列出所有环境
conda env list
conda info --envs
# 激活环境
conda activate myenv
# 停用环境
conda deactivate
# 删除环境
conda env remove -n myenv --all [-y]

# 包管理
conda install [-n <env>] <name>[=<版本>] 	# 默认在当前环境安装
conda update <name>		# 更新包及其依赖
conda update --all 	# 谨慎使用，或导致依赖冲突，推荐用mamba
conda remove <name> 	# 卸载

conda env export > environment.yml		# 导出环境配置
conda env create -f environment.yml		# 从配置文件创建环境

conda clean --all		# 清理缓存
```

> :warning: 注意：
>
> ​	指定安装版本时使用的`=`和`==`问题： `=`表示兼容此版本的最新小版本，`==`表示精确匹配版本
>
> 	- pip/uv/pipenv永远用`==`
> 	- conda/mamba默认用`=`，仅需固定时用`==`+`构建号`



# 六、文件操作

## 通用读写操作

- `read(size=-1)`: 从文件中读取字符串/字节, size限制字符数/字节数, -1表示无限制
- `readline(size=-1)`: 在读取到换行符或文件尾时返回单行字符串, 若已到文件尾, 则返回空字符串
- `readlines()`: 读取文件数据到一个字符串/字节列表中, 每一行都是列表的一个元素
- `write(s/b)`: 将字符串s/b字节写入文件中, 并返回写入的字符数/字节数
- `writelines(lines)`: 向文件中写入字符串/字节列表, 不加行分隔符, 故通常为每一行末尾提供行分隔符
- `flush()`: 刷新写缓冲区, 在文件没有关闭的情况下将数据写入文件中

## `open()`打开文件

```python
open(file, mode='r', encoding=None, errors=None)
```

- `file`​：要打开的文件, 可以是字符串/整数类型

  - 字符串: 表示文件名, 可以是相对/绝对路径

  - 整数: 表示一个已经打开的文件
  
- `mode`：设置文件打开模式，若文件不存在, 则创建文件, 仅限于最后一级不存在

  | 模式字符串  | 说明                                              |
  | :---------- | :------------------------------------------------ |
  | `rt` 或 `r` | 以只读模式打开文本文件                            |
  | `wt` 或 `w` | 以只写模式打开文本文件（覆盖现有内容）            |
  | `xt` 或 `x` | 以独占创建模式打开文本文件（文件必须不存在）      |
  | `at` 或 `a` | 以追加模式打开文本文件（在文件末尾添加内容）      |
  | `rb`        | 二进制文件模式（只读），类似于 `rt`               |
  | `wb`        | 二进制文件模式（只写），类似于 `wt`               |
  | `xb`        | 二进制文件模式（独占创建），类似于 `xt`           |
  | `ab`        | 二进制文件模式（追加），类似于 `at`               |
  | `r+`        | 以读写模式打开文本文件（文件必须存在）            |
  | `w+`        | 以读写模式打开文本文件（创建新文件/覆盖现有内容） |
  | `a+`        | 以读追加模式打开文本文件（允许读取和追加）        |
  | `rb+`       | 二进制文件模式（读写），类似于 `r+`               |
  | `wb+`       | 二进制文件模式（读写），类似于 `w+`               |
  | `ab+`       | 二进制文件模式（读追加），类似于 `a+`             |

- `encoding`​：用来指定打开文件时的编码, 默认None, 用操作系统默认的编码, 主要用于打开文本文件
- `errors`​：指定在发生错误时如何处理, 推荐取值为`ignore`, 表示忽略该错误, 程序继续执行

## `close()`关闭文件

- 推荐close放在finally代码块中, 保证对文件的操作无论正常结束与否都能关闭文件

  ```python
  finally:
  	if f is not None:
  		f.close()
  		print('关闭文件成功')
  ```
- `with as`​上下文操作语句, 代码块结束之后自动释放资源、关闭文件

  ```python
  f_name = 'test.txt'
  with open(f_name) as f:
  	content = f.read()
  	print(content)
  ```

‍

---

‍

# 七、异常处理

尽可能用内置的异常处理语句替换try语句, 如with语句、getattr()方法(其底层逻辑已处理了异常)

:triangular_flag_on_post: Python原则: EAFP优于LBYL，宁可用异常处理, 不做繁杂的条件控制

- EAFP：Easier to Ask Forgiveness than Permission
- LBYL：Look Before You Leap

## Traceback信息

- 异常堆栈信息, 描述程序运行的过程及引发异常的信息
- 异常发生文件、异常发生行数、异常发生表达式、异常信息描述

Exception、Error、Warning 统称异常

**分类：**

- `BaseException`: `Exception`的父类, 还包含SystemExit、KeyboardInterruptd、GeneratorExit, 属于高级异常, 平时不应使用, 应该交给解释器处理
- `Exception`: 所有错误的父类
- `ZeroDivisionError`: 任何数都不能除以0
- `TypeError`​、`NameError`​、`KeyError`​、`IndexError`​、`IdentationError`​……

**起别名:** `except 异常 as e`: e为异常对象, 一个变量

## 捕获异常

try-except语句: 可嵌套

```python
try: 
	可能引发异常的语句 		# 若try有异常, 执行except后面代码
except [异常类型1]:  			# 按顺序一次匹配 
	代码
except [异常类型2, 异常类型3...] as e:	# 多重异常捕获，可起别名
	代码
except:  	# 异常类型若省略, 必须放在最后, 捕获上面未匹配的所有异常类, 相当于except Exception
	代码
[else:		# try无异常则else, 可省略, 有else必有except
    code]
[finally:	# 可省略，有finally可省略except，无论try是否正常结束均执行finally
	code]
```

简化: 使用`with as`​

```python
with expression [as variable]:
	with_block
```

先执行`__enter__()`​函数(返回值赋给as后的variable, 若无as variable, 会忽略返回值)，再执行with-block语句，无论成败, 执行\_\_exit\_\_函数

## 自定义异常类

```python
class 自定义异常名(Exception):		# 需要继承Exception类或其子类
	def __init__(self, message):
		super().__init__(message)
```

## raise语句

主动抛出异常，若捕获异常后想重新抛出, 用不带参数的raise即可(一行只有raise一个单词)

```python
raise **Exception(message)
```

## assert语句

Python调试工具, 用于开发阶段进行参数检查、错误检查和验证假设, 生产环境中`assert`​语句通常会被禁用(不应被用于实际的错误处理)

> Python优化模式: 使用`-O`​参数运行Python, 忽略所有`assert`​语句

```python
# condition为False则抛AssertionError异常, True则无事发生
assert condition [, "Error message"]	# 可选择性地提供错误消息Error message

assert x == 10, "x should be 10, but it is {}".format(x)
assert age >= 18, "Age must be at least 18"
```

## Debug调试

- 打断点：断点当前行不执行 
- step over：逐行执行代码 
- step into：跳转进入当前行调用的函数 <不论函数是否在当前脚本文件内，都跳转> 
- step into my code：只跳转当前脚本文件内的函数内部 
- step out：从里面一层的函数跳转到外边一层 
- run to cursor：运行到光标选定的代码处

# 八、编程规范

## Shabang与元数据

### **1. 解释器路径（Shebang）**

shebang: `#!`​, 英语译为事情，工作，是 Unix/Linux 系统中脚本文件的特殊标记，在整个文件的开头，直接运行脚本时，系统会通过 shebang 指定的解释器来执行代码，而无需显式调用python

```python
#!/usr/bin/env python3  	# 这种写法比写绝对路径灵活，明确指定使用python3
```

- 作用：指定脚本的解释器路径，确保直接执行时使用正确的 Python 版本。
- 推荐写法：`python3`​ 而非 `python`​（避免混淆 Python 2/x）。

---

### **2. 编码声明**

```python
# -*- coding: utf-8 -*-		# 最常见写法
# -*- coding: gbk -*-        # 其他编码（如中文 Windows 常用）
# -*- coding: utf-8 -*-
   # 注意：声明必须放在文件开头（前几行内）
```

- PEP 0263规范，以`# -*-`​开头，以`-*-`​结尾，中间为键值对
- 作用：声明文件编码（Python 3 默认 UTF-8，但显式声明可提高兼容性）。
- 可选值：`utf-8`​, `gbk`​ 等，根据文件实际编码填写。

---

### **3. 作者与时间**

```python
# Author: Your Name <your.email@example.com>
# Date: 2023-10-05
```

- 作用：记录作者信息和创建/修改时间。
- 扩展：可添加版本号、版权声明或许可证信息（如 `# License: MIT`​）。

---

### **4. 其他元数据（可选）**

```python
# Description: A brief summary of the script's purpose.
# Usage: python script.py [options]
```

---

### **完整示例**

```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# Author: Alice <alice.dev@example.com>
# Date: 2023-10-05
# Description: Process data and generate reports.
# Usage: python report_generator.py input.csv
```



# 类型注解

两种：

- 函数参数：

    ```python
    def foo(attr: type, attr: type) -> type:
    ```

- 类属性：写在docstring之后，`__init__`之前

    ```python
    class foo():
        attr: type
        attr: type = 0 	# 默认值
    ```

| 类型注解               | 描述                                                         |
| ---------------------- | ------------------------------------------------------------ |
| `int`​                  | 整数类型                                                     |
| `float`​                | 浮动点类型                                                   |
| `bool`​                 | 布尔类型，`True`​ 或 `False`​                                  |
| `str`​                  | 字符串类型                                                   |
| `bytes`​                | 字节序列类型                                                 |
| `list[X]`​              | 列表，元素类型为 `X`​（例如 `list[int]`​ 表示整数列表）        |
| `tuple[X, Y, ...]`​     | 元组，元素类型为 `X`​, `Y`​, ...（例如 `tuple[int, str]`​）     |
| `dict[K, V]`​           | 字典，键类型为 `K`​，值类型为 `V`​（例如 `dict[str, int]`​）    |
| `set[X]`​               | 集合，元素类型为 `X`​                                         |
| `frozenset[X]`​         | 冻结集合，元素类型为 `X`​                                     |
| `Optional[X]`​          | 可选类型，表示值可以为 `X`​ 或 `None`​（等价于 `Union[X, None]`​） |
| `Union[X, Y]`​          | 联合类型，表示值可以是 `X`​ 或 `Y`​                            |
| `Any`​                  | 任意类型，表示值可以是任意类型                               |
| `Callable[[X, Y], Z]`​  | 可调用类型，表示一个函数，输入类型为 `X`​ 和 `Y`​，返回类型为 `Z`​ |
| `Iterable[X]`​          | 可迭代类型，表示可以迭代的对象，元素类型为 `X`​               |
| `Iterator[X]`​          | 迭代器类型，表示一个迭代器，返回值类型为 `X`​                 |
| `Generator[X, Y, Z]`​   | 生成器类型，表示一个生成器，输入类型为 `X`​，输出类型为 `Y`​，返回值类型为 `Z`​ |
| `Type[X]`​              | 类型类型，表示 `X`​ 类型本身（例如 `Type[str]`​ 表示 `str`​ 类型） |
| `Literal[X]`​           | 字面量类型，表示精确的常量值 `X`​（例如 `Literal[42]`​）       |
| `Final`​                | 表示一个常量类型，不能被重新赋值或继承                       |
| `Sequence[X]`​          | 序列类型，表示一个支持索引、切片和迭代的容器，元素类型为 `X`​（例如 `Sequence[str]`​） |
| `Mapping[K, V]`​        | 映射类型，表示一个字典类型，键类型为 `K`​，值类型为 `V`​       |
| `MutableSequence[X]`​   | 可变序列类型，表示一个可以修改的序列，元素类型为 `X`​         |
| `MutableMapping[K, V]`​ | 可变映射类型，表示一个可以修改的映射（字典），键类型为 `K`​，值类型为 `V`​ |
| `Deque[X]`​             | 双端队列类型，元素类型为 `X`​（`collections.deque`​）          |
| `Counter[X]`​           | 计数器类型，表示一个计数的集合，元素类型为 `X`​（`collections.Counter`​） |
| `DefaultDict[K, V]`​    | 默认字典类型，键类型为 `K`​，值类型为 `V`​（`collections.defaultdict`​） |

‍
